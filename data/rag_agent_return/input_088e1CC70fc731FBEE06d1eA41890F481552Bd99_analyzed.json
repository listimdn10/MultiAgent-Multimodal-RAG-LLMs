{
  "address": "088e1CC70fc731FBEE06d1eA41890F481552Bd99",
  "code": "pragma solidity 0.5.15;\n\nlibrary Addresses {\n\n    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            size := extcodesize(account)\n\n        }\n\n        return size > 0;\n\n    }\n\n\n\n    function performEthTransfer(address recipient, uint256 amount) internal {\n\n        // solium-disable-next-line security/no-call-value\n\n        (bool success, ) = recipient.call.value(amount)(\"\"); // NOLINT: low-level-calls.\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n\n    }\n\n\n\n    /*\n\n      Safe wrapper around ERC20/ERC721 calls.\n\n      This is required because many deployed ERC20 contracts don't return a value.\n\n      See https://github.com/ethereum/solidity/issues/4116.\n\n    */\n\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\n\n        require(isContract(tokenAddress), \"BAD_TOKEN_ADDRESS\");\n\n        // solium-disable-next-line security/no-low-level-calls\n\n        // NOLINTNEXTLINE: low-level-calls.\n\n        (bool success, bytes memory returndata) = address(tokenAddress).call(callData);\n\n        require(success, string(returndata));\n\n\n\n        if (returndata.length > 0) {\n\n            require(abi.decode(returndata, (bool)), \"TOKEN_OPERATION_FAILED\");\n\n        }\n\n    }\n\n}\n\nlibrary StarkExTypes {\n\n\n\n    // Structure representing a list of verifiers (validity/availability).\n\n    // A statement is valid only if all the verifiers in the list agree on it.\n\n    // Adding a verifier to the list is immediate - this is used for fast resolution of\n\n    // any soundness issues.\n\n    // Removing from the list is time-locked, to ensure that any user of the system\n\n    // not content with the announced removal has ample time to leave the system before it is\n\n    // removed.\n\n    struct ApprovalChainData {\n\n        address[] list;\n\n        // Represents the time after which the verifier with the given address can be removed.\n\n        // Removal of the verifier with address A is allowed only in the case the value\n\n        // of unlockedForRemovalTime[A] != 0 and unlockedForRemovalTime[A] < (current time).\n\n        mapping (address => uint256) unlockedForRemovalTime;\n\n    }\n\n\n\n}\n\ncontract ExternalInitializer {\n\n\n\n    event LogExternalInitialize(bytes data);\n\n\n\n    function initialize(bytes calldata data) external;\n\n}\n\ncontract GovernanceStorage {\n\n\n\n    struct GovernanceInfoStruct {\n\n        mapping (address => bool) effectiveGovernors;\n\n        address candidateGovernor;\n\n        bool initialized;\n\n    }\n\n\n\n    // A map from a Governor tag to its own GovernanceInfoStruct.\n\n    mapping (string => GovernanceInfoStruct) internal governanceInfo;\n\n}\n\ncontract IFactRegistry {\n\n    /*\n\n      Returns true if the given fact was previously registered in the contract.\n\n    */\n\n    function isValid(bytes32 fact)\n\n        external view\n\n        returns(bool);\n\n}\n\ncontract Identity {\n\n\n\n    /*\n\n      Allows a caller, typically another contract,\n\n      to ensure that the provided address is of the expected type and version.\n\n    */\n\n    function identify()\n\n        external pure\n\n        returns(string memory);\n\n}\n\ncontract LibConstants {\n\n    // Durations for time locked mechanisms (in seconds).\n\n    // Note that it is known that miners can manipulate block timestamps\n\n    // up to a deviation of a few seconds.\n\n    // This mechanism should not be used for fine grained timing.\n\n\n\n    // The time required to cancel a deposit, in the case the operator does not move the funds\n\n    // to the off-chain storage.\n\n    uint256 public constant DEPOSIT_CANCEL_DELAY = 1 days;\n\n\n\n    // The time required to freeze the exchange, in the case the operator does not execute a\n\n    // requested full withdrawal.\n\n    uint256 public constant FREEZE_GRACE_PERIOD = 7 days;\n\n\n\n    // The time after which the exchange may be unfrozen after it froze. This should be enough time\n\n    // for users to perform escape hatches to get back their funds.\n\n    uint256 public constant UNFREEZE_DELAY = 365 days;\n\n\n\n    // Maximal number of verifiers which may co-exist.\n\n    uint256 public constant MAX_VERIFIER_COUNT = uint256(64);\n\n\n\n    // The time required to remove a verifier in case of a verifier upgrade.\n\n    uint256 public constant VERIFIER_REMOVAL_DELAY = FREEZE_GRACE_PERIOD + (21 days);\n\n\n\n    uint256 constant MAX_VAULT_ID = 2**31 - 1;\n\n    uint256 constant MAX_QUANTUM = 2**128 - 1;\n\n\n\n    address constant ZERO_ADDRESS = address(0x0);\n\n\n\n    uint256 constant K_MODULUS =\n\n    0x800000000000011000000000000000000000000000000000000000000000001;\n\n    uint256 constant K_BETA =\n\n    0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;\n\n\n\n    uint256 constant EXPIRATION_TIMESTAMP_BITS = 22;\n\n\n\n    uint256 internal constant MASK_250 =\n\n    0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    uint256 internal constant MASK_240 =\n\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    uint256 internal constant MINTABLE_ASSET_ID_FLAG = 1<<250;\n\n}\n\ncontract ProxyStorage is GovernanceStorage {\n\n\n\n    // Stores the hash of the initialization vector of the added implementation.\n\n    // Upon upgradeTo the implementation, the initialization vector is verified\n\n    // to be identical to the one submitted when adding the implementation.\n\n    mapping (address => bytes32) internal initializationHash;\n\n\n\n    // The time after which we can switch to the implementation.\n\n    mapping (address => uint256) internal enabledTime;\n\n\n\n    // A central storage of the flags whether implementation has been initialized.\n\n    // Note - it can be used flexibly enough to accommodate multiple levels of initialization\n\n    // (i.e. using different key salting schemes for different initialization levels).\n\n    mapping (bytes32 => bool) internal initialized;\n\n}\n\ncontract MainStorage is ProxyStorage {\n\n\n\n    IFactRegistry escapeVerifier_;\n\n\n\n    // Global dex-frozen flag.\n\n    bool stateFrozen;                               // NOLINT: constable-states.\n\n\n\n    // Time when unFreeze can be successfully called (UNFREEZE_DELAY after freeze).\n\n    uint256 unFreezeTime;                           // NOLINT: constable-states.\n\n\n\n    // Pending deposits.\n\n    // A map STARK key => asset id => vault id => quantized amount.\n\n    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) pendingDeposits;\n\n\n\n    // Cancellation requests.\n\n    // A map STARK key => asset id => vault id => request timestamp.\n\n    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) cancellationRequests;\n\n\n\n    // Pending withdrawals.\n\n    // A map STARK key => asset id => quantized amount.\n\n    mapping (uint256 => mapping (uint256 => uint256)) pendingWithdrawals;\n\n\n\n    // vault_id => escape used boolean.\n\n    mapping (uint256 => bool) escapesUsed;\n\n\n\n    // Number of escapes that were performed when frozen.\n\n    uint256 escapesUsedCount;                       // NOLINT: constable-states.\n\n\n\n    // Full withdrawal requests: stark key => vaultId => requestTime.\n\n    // stark key => vaultId => requestTime.\n\n    mapping (uint256 => mapping (uint256 => uint256)) fullWithdrawalRequests;\n\n\n\n    // State sequence number.\n\n    uint256 sequenceNumber;                         // NOLINT: constable-states uninitialized-state.\n\n\n\n    // Vaults Tree Root & Height.\n\n    uint256 vaultRoot;                              // NOLINT: constable-states uninitialized-state.\n\n    uint256 vaultTreeHeight;                        // NOLINT: constable-states uninitialized-state.\n\n\n\n    // Order Tree Root & Height.\n\n    uint256 orderRoot;                              // NOLINT: constable-states uninitialized-state.\n\n    uint256 orderTreeHeight;                        // NOLINT: constable-states uninitialized-state.\n\n\n\n    // True if and only if the address is allowed to add tokens.\n\n    mapping (address => bool) tokenAdmins;\n\n\n\n    // True if and only if the address is allowed to register users.\n\n    mapping (address => bool) userAdmins;\n\n\n\n    // True if and only if the address is an operator (allowed to update state).\n\n    mapping (address => bool) operators;\n\n\n\n    // Mapping of contract ID to asset data.\n\n    mapping (uint256 => bytes) assetTypeToAssetInfo;    // NOLINT: uninitialized-state.\n\n\n\n    // Mapping of registered contract IDs.\n\n    mapping (uint256 => bool) registeredAssetType;      // NOLINT: uninitialized-state.\n\n\n\n    // Mapping from contract ID to quantum.\n\n    mapping (uint256 => uint256) assetTypeToQuantum;    // NOLINT: uninitialized-state.\n\n\n\n    // This mapping is no longer in use, remains for backwards compatibility.\n\n    mapping (address => uint256) starkKeys_DEPRECATED;  // NOLINT: naming-convention.\n\n\n\n    // Mapping from STARK public key to the Ethereum public key of its owner.\n\n    mapping (uint256 => address) ethKeys;               // NOLINT: uninitialized-state.\n\n\n\n    // Timelocked state transition and availability verification chain.\n\n    StarkExTypes.ApprovalChainData verifiersChain;\n\n    StarkExTypes.ApprovalChainData availabilityVerifiersChain;\n\n\n\n    // Batch id of last accepted proof.\n\n    uint256 lastBatchId;                            // NOLINT: constable-states uninitialized-state.\n\n\n\n    // Mapping between sub-contract index to sub-contract address.\n\n    mapping(uint256 => address) subContracts;       // NOLINT: uninitialized-state.\n\n}\n\ncontract ChangeVerifiersExternalInitializer is\n\n    ExternalInitializer,\n\n    MainStorage,\n\n    LibConstants\n\n{\n\n    using Addresses for address;\n\n    uint256 constant ENTRY_NOT_FOUND = uint256(~0);\n\n\n\n    /*\n\n      The initiatialize function gets four parameters in the bytes array:\n\n      1. New verifier address,\n\n      2. Keccak256 of the expected verifier id.\n\n      3. New availability verifier address,\n\n      4. Keccak256 of the expected availability verifier id.\n\n    */\n\n    function initialize(bytes calldata data) external {\n\n        require(data.length == 128, \"UNEXPECTED_DATA_SIZE\");\n\n        address newVerifierAddress;\n\n        bytes32 verifierIdHash;\n\n        address newAvailabilityVerifierAddress;\n\n        bytes32 availabilityVerifierIdHash;\n\n\n\n        // Extract sub-contract address and hash of verifierId.\n\n        (\n\n            newVerifierAddress,\n\n            verifierIdHash,\n\n            newAvailabilityVerifierAddress,\n\n            availabilityVerifierIdHash\n\n        ) = abi.decode(data, (address, bytes32, address, bytes32));\n\n\n\n        // Flush the entire verifiers list.\n\n        delete verifiersChain.list;\n\n        delete availabilityVerifiersChain.list;\n\n\n\n        // ApprovalChain addEntry performs all the required checks for us.\n\n        addEntry(verifiersChain, newVerifierAddress, MAX_VERIFIER_COUNT, verifierIdHash);\n\n        addEntry(\n\n            availabilityVerifiersChain, newAvailabilityVerifierAddress,\n\n            MAX_VERIFIER_COUNT, availabilityVerifierIdHash);\n\n\n\n        emit LogExternalInitialize(data);\n\n    }\n\n\n\n    /*\n\n      The functions below are taken from ApprovalChain.sol, with minor changes:\n\n      1. No governance needed (we are under the context where proxy governance is granted).\n\n      2. The verifier ID is passed as hash, and not as string.\n\n    */\n\n    function addEntry(\n\n        StarkExTypes.ApprovalChainData storage chain,\n\n        address entry, uint256 maxLength, bytes32 hashExpectedId)\n\n        internal\n\n    {\n\n        address[] storage list = chain.list;\n\n        require(entry.isContract(), \"ADDRESS_NOT_CONTRACT\");\n\n        bytes32 hashRealId = keccak256(abi.encodePacked(Identity(entry).identify()));\n\n        require(hashRealId == hashExpectedId, \"UNEXPECTED_CONTRACT_IDENTIFIER\");\n\n        require(list.length < maxLength, \"CHAIN_AT_MAX_CAPACITY\");\n\n        require(findEntry(list, entry) == ENTRY_NOT_FOUND, \"ENTRY_ALREADY_EXISTS\");\n\n        chain.list.push(entry);\n\n        chain.unlockedForRemovalTime[entry] = 0;\n\n    }\n\n\n\n    function findEntry(address[] storage list, address entry)\n\n        internal view returns (uint256)\n\n    {\n\n        uint256 n_entries = list.length;\n\n        for (uint256 i = 0; i < n_entries; i++) {\n\n            if (list[i] == entry) {\n\n                return i;\n\n            }\n\n        }\n\n        return ENTRY_NOT_FOUND;\n\n    }\n\n}\n",
  "functional_semantic": "Abstract purpose: This code defines a Solidity library and contracts for managing and upgrading verifiers and availability verifiers in a StarkEx system.\n\nDetail Behaviors:\n1.  Defines the `Addresses` library, which includes functions to check if an address is a contract, perform ETH transfers, and safely call token contract functions.\n2.  Defines `StarkExTypes` library, which contains data structures for managing verifier approval chains.\n3.  Defines abstract contract `ExternalInitializer` which declares an `initialize` function to be implemented by contracts used for external initialization.\n4.  Defines contract `GovernanceStorage` for storing governance information, including effective governors and candidate governors.\n5.  Defines interface `IFactRegistry` for checking the validity of facts.\n6.  Defines interface `Identity` for identifying the type and version of a contract.\n7.  Defines contract `LibConstants` that stores constants such as time delays and maximum values.\n8.  Defines contract `ProxyStorage` that stores information related to contract upgrades, such as initialization hashes and enabled times.\n9.  Defines contract `MainStorage` that stores the main state variables of the StarkEx system, including pending deposits, withdrawals, vault data, and verifier chains.\n10. Defines contract `ChangeVerifiersExternalInitializer`, which inherits from multiple contracts and includes functionality to replace the current verifier and availability verifier addresses.\n11. Implement functions to add entries to the verifier and availability verifier chains, ensuring the new entries are valid contracts with expected identifiers.\n",
  "vuln": "['access-control']",
  "context_retrieved": {
    "functionality": "code block 1:\\n1.  the code block is a function named `_calloptionalreturn` which is declared as private.\\n2.  it takes two parameters: `token` of type `ierc20` and `data` of type `bytes`.\\n3.  the function performs a low-level call to the `token` contract using the `functioncall` method.\\n4.  the `functioncall` method is used to bypass solidity's return data size checking mechanism.\\n5.  the function verifies that the target address contains contract code and asserts for success in the low-level call.\\n6.  if the return data is not empty, the function checks if the return data can be decoded into a boolean value.\\n7.  if the return data cannot be decoded or if the decoded value is not `true`, the function throws an exception.\\n\\nhigh-level overview and purpose:\\nthe purpose of this code block is to provide a safe way to call an erc20 token's function. the function is designed to bypass solidity's return data size checking mechanism, which allows for more flexibility when interacting with erc20 tokens. the function also checks if the return data is valid and throws an exception if it's not. this ensures that the function call is successful and the return data is valid.\\n\\nin a wider context, this code block is likely part of a smart contract that interacts with erc20 tokens. the contract may use this function to perform various operations such as transferring tokens, checking token balances, or getting token information. the function provides a safe and reliable way to interact with the erc20 token, ensuring that the contract behaves correctly and securely.",
    "vulnerable_code": "```\\nfunction _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\\n    if (returndata.length > 0) {\\n        // Return data is optional\\n        require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\\n    }\\n}\\n```\\n",
    "vulnerability": "",
    "type": "no vulnerability"
  },
  "context_similarity_score": 0.7934002876281738,
  "full_llm_prompt": "\n    You are a meticulous smart contract security analyst.\n    Your task is to compare the [Solidity Code (To be analyzed)] against the [Retrieved Context].\n\n    ---\n    [Solidity Code (To be analyzed)]:\n    ```solidity\n    pragma solidity 0.5.15;\n\nlibrary Addresses {\n\n    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            size := extcodesize(account)\n\n        }\n\n        return size > 0;\n\n    }\n\n\n\n    function performEthTransfer(address recipient, uint256 amount) internal {\n\n        // solium-disable-next-line security/no-call-value\n\n        (bool success, ) = recipient.call.value(amount)(\"\"); // NOLINT: low-level-calls.\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n\n    }\n\n\n\n    /*\n\n      Safe wrapper around ERC20/ERC721 calls.\n\n      This is required because many deployed ERC20 contracts don't return a value.\n\n      See https://github.com/ethereum/solidity/issues/4116.\n\n    */\n\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\n\n        require(isContract(tokenAddress), \"BAD_TOKEN_ADDRESS\");\n\n        // solium-disable-next-line security/no-low-level-calls\n\n        // NOLINTNEXTLINE: low-level-calls.\n\n        (bool success, bytes memory returndata) = address(tokenAddress).call(callData);\n\n        require(success, string(returndata));\n\n\n\n        if (returndata.length > 0) {\n\n            require(abi.decode(returndata, (bool)), \"TOKEN_OPERATION_FAILED\");\n\n        }\n\n    }\n\n}\n\nlibrary StarkExTypes {\n\n\n\n    // Structure representing a list of verifiers (validity/availability).\n\n    // A statement is valid only if all the verifiers in the list agree on it.\n\n    // Adding a verifier to the list is immediate - this is used for fast resolution of\n\n    // any soundness issues.\n\n    // Removing from the list is time-locked, to ensure that any user of the system\n\n    // not content with the announced removal has ample time to leave the system before it is\n\n    // removed.\n\n    struct ApprovalChainData {\n\n        address[] list;\n\n        // Represents the time after which the verifier with the given address can be removed.\n\n        // Removal of the verifier with address A is allowed only in the case the value\n\n        // of unlockedForRemovalTime[A] != 0 and unlockedForRemovalTime[A] < (current time).\n\n        mapping (address => uint256) unlockedForRemovalTime;\n\n    }\n\n\n\n}\n\ncontract ExternalInitializer {\n\n\n\n    event LogExternalInitialize(bytes data);\n\n\n\n    function initialize(bytes calldata data) external;\n\n}\n\ncontract GovernanceStorage {\n\n\n\n    struct GovernanceInfoStruct {\n\n        mapping (address => bool) effectiveGovernors;\n\n        address candidateGovernor;\n\n        bool initialized;\n\n    }\n\n\n\n    // A map from a Governor tag to its own GovernanceInfoStruct.\n\n    mapping (string => GovernanceInfoStruct) internal governanceInfo;\n\n}\n\ncontract IFactRegistry {\n\n    /*\n\n      Returns true if the given fact was previously registered in the contract.\n\n    */\n\n    function isValid(bytes32 fact)\n\n        external view\n\n        returns(bool);\n\n}\n\ncontract Identity {\n\n\n\n    /*\n\n      Allows a caller, typically another contract,\n\n      to ensure that the provided address is of the expected type and version.\n\n    */\n\n    function identify()\n\n        external pure\n\n        returns(string memory);\n\n}\n\ncontract LibConstants {\n\n    // Durations for time locked mechanisms (in seconds).\n\n    // Note that it is known that miners can manipulate block timestamps\n\n    // up to a deviation of a few seconds.\n\n    // This mechanism should not be used for fine grained timing.\n\n\n\n    // The time required to cancel a deposit, in the case the operator does not move the funds\n\n    // to the off-chain storage.\n\n    uint256 public constant DEPOSIT_CANCEL_DELAY = 1 days;\n\n\n\n    // The time required to freeze the exchange, in the case the operator does not execute a\n\n    // requested full withdrawal.\n\n    uint256 public constant FREEZE_GRACE_PERIOD = 7 days;\n\n\n\n    // The time after which the exchange may be unfrozen after it froze. This should be enough time\n\n    // for users to perform escape hatches to get back their funds.\n\n    uint256 public constant UNFREEZE_DELAY = 365 days;\n\n\n\n    // Maximal number of verifiers which may co-exist.\n\n    uint256 public constant MAX_VERIFIER_COUNT = uint256(64);\n\n\n\n    // The time required to remove a verifier in case of a verifier upgrade.\n\n    uint256 public constant VERIFIER_REMOVAL_DELAY = FREEZE_GRACE_PERIOD + (21 days);\n\n\n\n    uint256 constant MAX_VAULT_ID = 2**31 - 1;\n\n    uint256 constant MAX_QUANTUM = 2**128 - 1;\n\n\n\n    address constant ZERO_ADDRESS = address(0x0);\n\n\n\n    uint256 constant K_MODULUS =\n\n    0x800000000000011000000000000000000000000000000000000000000000001;\n\n    uint256 constant K_BETA =\n\n    0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;\n\n\n\n    uint256 constant EXPIRATION_TIMESTAMP_BITS = 22;\n\n\n\n    uint256 internal constant MASK_250 =\n\n    0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    uint256 internal constant MASK_240 =\n\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    uint256 internal constant MINTABLE_ASSET_ID_FLAG = 1<<250;\n\n}\n\ncontract ProxyStorage is GovernanceStorage {\n\n\n\n    // Stores the hash of the initialization vector of the added implementation.\n\n    // Upon upgradeTo the implementation, the initialization vector is verified\n\n    // to be identical to the one submitted when adding the implementation.\n\n    mapping (address => bytes32) internal initializationHash;\n\n\n\n    // The time after which we can switch to the implementation.\n\n    mapping (address => uint256) internal enabledTime;\n\n\n\n    // A central storage of the flags whether implementation has been initialized.\n\n    // Note - it can be used flexibly enough to accommodate multiple levels of initialization\n\n    // (i.e. using different key salting schemes for different initialization levels).\n\n    mapping (bytes32 => bool) internal initialized;\n\n}\n\ncontract MainStorage is ProxyStorage {\n\n\n\n    IFactRegistry escapeVerifier_;\n\n\n\n    // Global dex-frozen flag.\n\n    bool stateFrozen;                               // NOLINT: constable-states.\n\n\n\n    // Time when unFreeze can be successfully called (UNFREEZE_DELAY after freeze).\n\n    uint256 unFreezeTime;                           // NOLINT: constable-states.\n\n\n\n    // Pending deposits.\n\n    // A map STARK key => asset id => vault id => quantized amount.\n\n    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) pendingDeposits;\n\n\n\n    // Cancellation requests.\n\n    // A map STARK key => asset id => vault id => request timestamp.\n\n    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) cancellationRequests;\n\n\n\n    // Pending withdrawals.\n\n    // A map STARK key => asset id => quantized amount.\n\n    mapping (uint256 => mapping (uint256 => uint256)) pendingWithdrawals;\n\n\n\n    // vault_id => escape used boolean.\n\n    mapping (uint256 => bool) escapesUsed;\n\n\n\n    // Number of escapes that were performed when frozen.\n\n    uint256 escapesUsedCount;                       // NOLINT: constable-states.\n\n\n\n    // Full withdrawal requests: stark key => vaultId => requestTime.\n\n    // stark key => vaultId => requestTime.\n\n    mapping (uint256 => mapping (uint256 => uint256)) fullWithdrawalRequests;\n\n\n\n    // State sequence number.\n\n    uint256 sequenceNumber;                         // NOLINT: constable-states uninitialized-state.\n\n\n\n    // Vaults Tree Root & Height.\n\n    uint256 vaultRoot;                              // NOLINT: constable-states uninitialized-state.\n\n    uint256 vaultTreeHeight;                        // NOLINT: constable-states uninitialized-state.\n\n\n\n    // Order Tree Root & Height.\n\n    uint256 orderRoot;                              // NOLINT: constable-states uninitialized-state.\n\n    uint256 orderTreeHeight;                        // NOLINT: constable-states uninitialized-state.\n\n\n\n    // True if and only if the address is allowed to add tokens.\n\n    mapping (address => bool) tokenAdmins;\n\n\n\n    // True if and only if the address is allowed to register users.\n\n    mapping (address => bool) userAdmins;\n\n\n\n    // True if and only if the address is an operator (allowed to update state).\n\n    mapping (address => bool) operators;\n\n\n\n    // Mapping of contract ID to asset data.\n\n    mapping (uint256 => bytes) assetTypeToAssetInfo;    // NOLINT: uninitialized-state.\n\n\n\n    // Mapping of registered contract IDs.\n\n    mapping (uint256 => bool) registeredAssetType;      // NOLINT: uninitialized-state.\n\n\n\n    // Mapping from contract ID to quantum.\n\n    mapping (uint256 => uint256) assetTypeToQuantum;    // NOLINT: uninitialized-state.\n\n\n\n    // This mapping is no longer in use, remains for backwards compatibility.\n\n    mapping (address => uint256) starkKeys_DEPRECATED;  // NOLINT: naming-convention.\n\n\n\n    // Mapping from STARK public key to the Ethereum public key of its owner.\n\n    mapping (uint256 => address) ethKeys;               // NOLINT: uninitialized-state.\n\n\n\n    // Timelocked state transition and availability verification chain.\n\n    StarkExTypes.ApprovalChainData verifiersChain;\n\n    StarkExTypes.ApprovalChainData availabilityVerifiersChain;\n\n\n\n    // Batch id of last accepted proof.\n\n    uint256 lastBatchId;                            // NOLINT: constable-states uninitialized-state.\n\n\n\n    // Mapping between sub-contract index to sub-contract address.\n\n    mapping(uint256 => address) subContracts;       // NOLINT: uninitialized-state.\n\n}\n\ncontract ChangeVerifiersExternalInitializer is\n\n    ExternalInitializer,\n\n    MainStorage,\n\n    LibConstants\n\n{\n\n    using Addresses for address;\n\n    uint256 constant ENTRY_NOT_FOUND = uint256(~0);\n\n\n\n    /*\n\n      The initiatialize function gets four parameters in the bytes array:\n\n      1. New verifier address,\n\n      2. Keccak256 of the expected verifier id.\n\n      3. New availability verifier address,\n\n      4. Keccak256 of the expected availability verifier id.\n\n    */\n\n    function initialize(bytes calldata data) external {\n\n        require(data.length == 128, \"UNEXPECTED_DATA_SIZE\");\n\n        address newVerifierAddress;\n\n        bytes32 verifierIdHash;\n\n        address newAvailabilityVerifierAddress;\n\n        bytes32 availabilityVerifierIdHash;\n\n\n\n        // Extract sub-contract address and hash of verifierId.\n\n        (\n\n            newVerifierAddress,\n\n            verifierIdHash,\n\n            newAvailabilityVerifierAddress,\n\n            availabilityVerifierIdHash\n\n        ) = abi.decode(data, (address, bytes32, address, bytes32));\n\n\n\n        // Flush the entire verifiers list.\n\n        delete verifiersChain.list;\n\n        delete availabilityVerifiersChain.list;\n\n\n\n        // ApprovalChain addEntry performs all the required checks for us.\n\n        addEntry(verifiersChain, newVerifierAddress, MAX_VERIFIER_COUNT, verifierIdHash);\n\n        addEntry(\n\n            availabilityVerifiersChain, newAvailabilityVerifierAddress,\n\n            MAX_VERIFIER_COUNT, availabilityVerifierIdHash);\n\n\n\n        emit LogExternalInitialize(data);\n\n    }\n\n\n\n    /*\n\n      The functions below are taken from ApprovalChain.sol, with minor changes:\n\n      1. No governance needed (we are under the context where proxy governance is granted).\n\n      2. The verifier ID is passed as hash, and not as string.\n\n    */\n\n    function addEntry(\n\n        StarkExTypes.ApprovalChainData storage chain,\n\n        address entry, uint256 maxLength, bytes32 hashExpectedId)\n\n        internal\n\n    {\n\n        address[] storage list = chain.list;\n\n        require(entry.isContract(), \"ADDRESS_NOT_CONTRACT\");\n\n        bytes32 hashRealId = keccak256(abi.encodePacked(Identity(entry).identify()));\n\n        require(hashRealId == hashExpectedId, \"UNEXPECTED_CONTRACT_IDENTIFIER\");\n\n        require(list.length < maxLength, \"CHAIN_AT_MAX_CAPACITY\");\n\n        require(findEntry(list, entry) == ENTRY_NOT_FOUND, \"ENTRY_ALREADY_EXISTS\");\n\n        chain.list.push(entry);\n\n        chain.unlockedForRemovalTime[entry] = 0;\n\n    }\n\n\n\n    function findEntry(address[] storage list, address entry)\n\n        internal view returns (uint256)\n\n    {\n\n        uint256 n_entries = list.length;\n\n        for (uint256 i = 0; i < n_entries; i++) {\n\n            if (list[i] == entry) {\n\n                return i;\n\n            }\n\n        }\n\n        return ENTRY_NOT_FOUND;\n\n    }\n\n}\n\n    ```\n    ---\n    [Retrieved Context]:\n    (This context describes a vulnerability found in a *similar* piece of code)\n    --- BEGIN CONTEXT FROM KNOWLEDGE GRAPH (Similarity Score: 0.7934) ---\n**Retrieved Type:** no vulnerability\n\n**Retrieved Vulnerability:**\n\n\n--- END CONTEXT FROM KNOWLEDGE GRAPH ---\n    ---\n\n    YOUR INSTRUCTIONS:\n    1.  First, analyze the [Retrieved Context]. What specific vulnerability does it describe?\n    2.  Second, carefully examine the [Solidity Code (To be analyzed)].\n    3.  Finally, answer this critical question: Does the [Solidity Code (To be analyzed)] **ALSO** contain the *exact same vulnerability* described in the [Retrieved Context]?\n\n    Please output your findings in this exact format:\n\n    **Vulnerability Name:** <Name of vulnerability or Non-vulnerable if not find>\n    **Reasoning:** <Explain *why* the code is (or is not) vulnerable, comparing it *directly* to the context.>\n    **Recommendation:** <Your suggestion based on the analysis.>\n    \n    ### Response:\n    **Vulnerability Name:**",
  "raw_llm_output": "**Vulnerability Status:** None\n    **Reasoning:** The `addEntry` function in the `ChangeVerifiersExternalInitializer` contract is responsible for adding entries to the approval chain. It takes three parameters: `newVerifierAddress`, `verifierIdHash`, and `newAvailabilityVerifierAddress`. However, there is a discrepancy in the way these parameters are handled. Specifically, while `newVerifierAddress` and `newAvailabilityVerifierAddress` are directly assigned to the `chain.list` array, `verifierIdHash` is not properly validated. Instead, it is simply checked against the `hashExpectedId` variable without being stored in the `chain.list` array. This means that the `addEntry` function will always succeed, even if the `verifierIdHash` does not match the `hashExpectedId`.\n    **Recommendation:** To prevent unauthorized access to the approval chain, it is recommended to store the `verifierIdHash` in the `chain.list` array along with the `newVerifierAddress` and `newAvailabilityVerifierAddress`. This ensures that the integrity of the approval chain is maintained and prevents potential attacks. Additionally, it is essential to validate the `verifierIdHash` against the `hashExpectedId` before storing it in the `chain.list` array. This validation step helps to detect and prevent any attempts to tamper with the approval chain.\n  - Recommendation: None\n"
}