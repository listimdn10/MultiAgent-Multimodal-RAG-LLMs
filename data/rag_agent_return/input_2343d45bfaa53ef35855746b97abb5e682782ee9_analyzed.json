{
  "address": "2343d45bfaa53ef35855746b97abb5e682782ee9",
  "code": "pragma solidity 0.4.26;\n\ninterface IERC20 {\n\n    /**\n\n     * @dev Returns the amount of tokens in existence.\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the amount of tokens owned by `account`.\n\n     */\n\n    function balanceOf(address who) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the remaining number of tokens that `spender` will be\n\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n\n     * zero by default.\n\n     *\n\n     * This value changes when `approve` or `transferFrom` are called.\n\n     */\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a `Transfer` event.\n\n     */\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * > Beware that changing an allowance with this method brings the risk\n\n     * that someone may use both the old and the new allowance by unfortunate\n\n     * transaction ordering. One possible solution to mitigate this race\n\n     * condition is to first reduce the spender's allowance to 0 and set the\n\n     * desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     *\n\n     * Emits an `Approval` event.\n\n     */\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\n     * allowance mechanism. `amount` is then deducted from the caller's\n\n     * allowance.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a `Transfer` event.\n\n     */\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n\n\n    /**\n\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * Note that `value` may be zero.\n\n     */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    /**\n\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\n     * a call to `approve`. `value` is the new allowance.\n\n     */\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\ncontract Ownable {\n\n    address private _owner;\n\n\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n    /**\n\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n    * account.\n\n    */\n\n    constructor() public {\n\n        _owner = msg.sender;\n\n    }\n\n\n\n    /**\n\n    * @return the address of the owner.\n\n    */\n\n    function owner() public view returns(address) {\n\n        return _owner;\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the owner.\n\n    */\n\n    modifier onlyOwner() {\n\n        require(_isOwner());\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @return true if `msg.sender` is the owner of the contract.\n\n    */\n\n    function _isOwner() internal view returns(bool) {\n\n        return msg.sender == _owner;\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n    * @param newOwner The address to transfer ownership to.\n\n    */\n\n    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n\n    }\n\n\n\n    /**\n\n    * @dev Transfers control of the contract to a newOwner.\n\n    * @param newOwner The address to transfer ownership to.\n\n    */\n\n    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(_owner, newOwner);\n\n        _owner = newOwner;\n\n    }\n\n}\n\nlibrary SafeMath {\n\n\n\n    /**\n\n    * @dev Multiplies two numbers, reverts on overflow.\n\n    */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\n        // benefit is lost if 'b' is also tested.\n\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint256 c = a * b;\n\n        require(c / a == b);\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n\n    */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n\n    */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b <= a);\n\n        uint256 c = a - b;\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two numbers, reverts on overflow.\n\n    */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        require(c >= a);\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n\n    * reverts when dividing by zero.\n\n    */\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b != 0);\n\n        return a % b;\n\n    }\n\n}\n\ncontract Stoppable is Ownable{\n\n    bool public stopped = false;\n\n    \n\n    modifier enabled {\n\n        require (!stopped);\n\n        _;\n\n    }\n\n    \n\n    function stop() external onlyOwner { \n\n        stopped = true; \n\n    }\n\n    \n\n    function start() external onlyOwner {\n\n        stopped = false;\n\n    }    \n\n}\n\ncontract ERC20 is IERC20 {\n\n    using SafeMath for uint256;\n\n\n\n    mapping (address => uint256) private _balances;\n\n\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n\n\n    uint256 private _totalSupply;\n\n\n\n    /**\n\n    * @dev Total number of tokens in existence\n\n    */\n\n    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the balance of the specified address.\n\n    * @param owner The address to query the balance of.\n\n    * @return An uint256 representing the amount owned by the passed address.\n\n    */\n\n    function balanceOf(address owner) public view returns (uint256) {\n\n        return _balances[owner];\n\n    }\n\n\n\n    /**\n\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n    * @param owner address The address which owns the funds.\n\n    * @param spender address The address which will spend the funds.\n\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n\n    */\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowed[owner][spender];\n\n    }\n\n\n\n    /**\n\n    * @dev Transfer token for a specified address\n\n    * @param to The address to transfer to.\n\n    * @param value The amount to be transferred.\n\n    */\n\n    function transfer(address to, uint256 value) public returns (bool) {\n\n        require(value <= _balances[msg.sender], \"ERC20: Overdrawn balance\");\n\n        require(to != address(0));\n\n\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n\n        _balances[to] = _balances[to].add(value);\n\n        emit Transfer(msg.sender, to, value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n    * @param spender The address which will spend the funds.\n\n    * @param value The amount of tokens to be spent.\n\n    */\n\n    function approve(address spender, uint256 value) public returns (bool) {\n\n        require(spender != address(0));\n\n\n\n        _allowed[msg.sender][spender] = value;\n\n        emit Approval(msg.sender, spender, value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Transfer tokens from one address to another\n\n    * @param from address The address which you want to send tokens from\n\n    * @param to address The address which you want to transfer to\n\n    * @param value uint256 the amount of tokens to be transferred\n\n    */\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n\n        require(value <= _balances[from], \"ERC20: Overdrawn balance\");\n\n        require(value <= _allowed[from][msg.sender]);\n\n        require(to != address(0));\n\n\n\n        _balances[from] = _balances[from].sub(value);\n\n        _balances[to] = _balances[to].add(value);\n\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n        emit Transfer(from, to, value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n\n    * approve should be called when allowed_[_spender] == 0. To increment\n\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n\n    * the first transaction is mined)\n\n    * From MonolithDAO Token.sol\n\n    * @param spender The address which will spend the funds.\n\n    * @param addedValue The amount of tokens to increase the allowance by.\n\n    */\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        require(spender != address(0));\n\n\n\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\n    * approve should be called when allowed_[_spender] == 0. To decrement\n\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n\n    * the first transaction is mined)\n\n    * From MonolithDAO Token.sol\n\n    * @param spender The address which will spend the funds.\n\n    * @param subtractedValue The amount of tokens to decrease the allowance by.\n\n    */\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        require(spender != address(0));\n\n\n\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function that mints an amount of the token and assigns it to\n\n    * an account. This encapsulates the modification of balances such that the\n\n    * proper events are emitted.\n\n    * @param account The account that will receive the created tokens.\n\n    * @param amount The amount that will be created.\n\n    */\n\n    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function that burns an amount of the token of a given\n\n    * account.\n\n    * @param account The account whose tokens will be burnt.\n\n    * @param amount The amount that will be burnt.\n\n    */\n\n    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0));\n\n        require(amount <= _balances[account], \"ERC20: Overdrawn balance\");\n\n\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        _balances[account] = _balances[account].sub(amount);\n\n        emit Transfer(account, address(0), amount);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function that burns an amount of the token of a given\n\n    * account, deducting from the sender's allowance for said account. Uses the\n\n    * internal burn function.\n\n    * @param account The account whose tokens will be burnt.\n\n    * @param amount The amount that will be burnt.\n\n    */\n\n    function _burnFrom(address account, uint256 amount) internal {\n\n        require(amount <= _allowed[account][msg.sender], \"ERC20: Overdrawn balance\");\n\n\n\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n\n        // this function needs to emit an event with the updated approval.\n\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);\n\n        _burn(account, amount);\n\n    }\n\n}\n\ncontract ERC20Burnable is ERC20 {\n\n\n\n    /**\n\n    * @dev Burns a specific amount of tokens.\n\n    * @param value The amount of token to be burned.\n\n    */\n\n    function burn(uint256 value) public {\n\n        _burn(msg.sender, value);\n\n    }\n\n\n\n    /**\n\n    * @dev Burns a specific amount of tokens from the target address and decrements allowance\n\n    * @param from address The address which you want to send tokens from\n\n    * @param value uint256 The amount of token to be burned\n\n    */\n\n    function burnFrom(address from, uint256 value) public {\n\n        _burnFrom(from, value);\n\n    }\n\n\n\n    /**\n\n    * @dev Overrides ERC20._burn in order for burn and burnFrom to emit\n\n    * an additional Burn event.\n\n    */\n\n    function _burn(address who, uint256 value) internal {\n\n        super._burn(who, value);\n\n    }\n\n}\n\ncontract ERC20Detailed is IERC20 {\n\n    string private _name;\n\n    string private _symbol;\n\n    uint8 private _decimals;\n\n\n\n    constructor(string memory name, string memory symbol, uint8 decimals) public {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = decimals;\n\n    }\n\n\n\n    /**\n\n    * @return the name of the token.\n\n    */\n\n    function name() public view returns(string memory) {\n\n        return _name;\n\n    }\n\n\n\n    /**\n\n    * @return the symbol of the token.\n\n    */\n\n    function symbol() public view returns(string memory) {\n\n        return _symbol;\n\n    }\n\n\n\n    /**\n\n    * @return the number of decimals of the token.\n\n    */\n\n    function decimals() public view returns(uint8) {\n\n        return _decimals;\n\n    }\n\n}\n\ncontract AXTToken is ERC20Detailed, /*ERC20,*/ ERC20Burnable, Stoppable {\n\n\n\n    constructor (\n\n            string memory name,\n\n            string memory symbol,\n\n            uint256 totalSupply,\n\n            uint8 decimals\n\n    ) ERC20Detailed(name, symbol, decimals)\n\n    public {\n\n        _mint(owner(), totalSupply * 10**uint(decimals));\n\n    }\n\n\n\n    // Don't accept ETH\n\n    function () payable external {\n\n        revert();\n\n    }\n\n\n\n    function mint(address account, uint256 amount) public onlyOwner returns (bool) {\n\n        _mint(account, amount);\n\n        return true;\n\n    }\n\n\n\n    //------------------------\n\n    // Lock account transfer \n\n\n\n    mapping (address => uint256) private _lockTimes;\n\n    mapping (address => uint256) private _lockAmounts;\n\n\n\n    event LockChanged(address indexed account, uint256 releaseTime, uint256 amount);\n\n\n\n    function setLock(address account, uint256 releaseTime, uint256 amount) onlyOwner public {\n\n        _lockTimes[account] = releaseTime; \n\n        _lockAmounts[account] = amount;\n\n        emit LockChanged( account, releaseTime, amount ); \n\n    }\n\n\n\n    function getLock(address account) public view returns (uint256 lockTime, uint256 lockAmount) {\n\n        return (_lockTimes[account], _lockAmounts[account]);\n\n    }\n\n\n\n    function _isLocked(address account, uint256 amount) internal view returns (bool) {\n\n        return _lockTimes[account] != 0 && \n\n            _lockAmounts[account] != 0 && \n\n            _lockTimes[account] > block.timestamp &&\n\n            (\n\n                balanceOf(account) <= _lockAmounts[account] ||\n\n                balanceOf(account).sub(_lockAmounts[account]) < amount\n\n            );\n\n    }\n\n\n\n    function transfer(address recipient, uint256 amount) enabled public returns (bool) {\n\n        require( !_isLocked( msg.sender, amount ) , \"ERC20: Locked balance\");\n\n        return super.transfer(recipient, amount);\n\n    }\n\n\n\n    function transferFrom(address sender, address recipient, uint256 amount) enabled public returns (bool) {\n\n        require( !_isLocked( sender, amount ) , \"ERC20: Locked balance\");\n\n        return super.transferFrom(sender, recipient, amount);\n\n    }\n\n\n\n\n\n}\n",
  "functional_semantic": "**Abstract purpose:** This code defines a token contract `AXTToken` that implements the ERC20 standard with burnable tokens, ownership control, a pause/stop mechanism, and account locking functionality to restrict token transfers.\n\n**Detail Behaviors:**\n1.  Defines the IERC20 interface for ERC20 token standard.\n2.  Implements Ownable contract to manage contract ownership and access control.\n3.  Includes SafeMath library to prevent integer overflows/underflows.\n4.  Creates Stoppable contract to allow pausing/unpausing contract functionality by the owner.\n5.  Implements ERC20 contract based on IERC20 interface to provide basic ERC20 token functionality.\n6.  Extends ERC20 with ERC20Burnable, adding token burning capabilities.\n7.  Creates ERC20Detailed contract for storing token name, symbol, and decimals.\n8.  Defines the AXTToken contract, inheriting from ERC20Detailed, ERC20Burnable, and Stoppable.\n9.  Allows the contract owner to mint new tokens via the `mint` function.\n10. Implements account locking features via `setLock` to restrict token transfers until a specified release time, preventing locked accounts from transferring tokens.\n11. Overrides `transfer` and `transferFrom` to check lock status before transferring tokens.\n",
  "vuln": "['locked-ether']",
  "context_retrieved": {
    "functionality": "code block 1:\\n1.  this function is used to transfer a specified amount of tokens from the sender to the recipient.\\n2.  it first calls a private function `_transfer` to perform the actual transfer.\\n3.  then, it checks if the sender's allowance for the recipient is sufficient to cover the transfer amount.\\n4.  if the allowance is not sufficient, it calls another function `_approve` to update the sender's allowance for the recipient.\\n5.  the `_approve` function also checks if the transfer amount exceeds the sender's allowance, and if so, it reverts the transaction.\\n6.  finally, the function returns a boolean value indicating whether the transfer was successful.\\n\\ncode block 2:\\n1.  this code checks if the allowance for the `lptoken` token, held by the contract, for the `ichifarm` address is not at its maximum value.\\n2.  if the allowance is not at its maximum, it calls the `safeapprove` function to set the allowance to its maximum value.\\n\\ncode block 3:\\n1.  this is an internal function used by the `safeapprove` function.\\n2.  it checks if the value being approved is zero or if the current allowance is also zero.\\n3.  if either condition is true, it reverts the transaction.\\n4.  otherwise, it calls the `approve` function of the `token` contract, passing the `spender` and `value` as arguments.\\n5.  the `approve` function is called using the `abi.encodewithselector` function to encode the function call, which allows the function to be called in a way that is compatible with the `token` contract.\\n\\nhigh-level overview and purpose:\\nthe code is part of a smart contract that manages the transfer of tokens between addresses. the `transferfrom` function is used to transfer tokens from the sender to the recipient, while also updating the sender's allowance for the recipient. the `safeapprove` function is used to set the allowance for the `ichifarm` address to its maximum value. the code ensures that the allowance is updated correctly and that the transfer amount does not exceed the sender's allowance. the purpose of the code is to provide a safe and secure way to transfer tokens between addresses while ensuring that the allowance is updated correctly.",
    "vulnerable_code": "```\\nfunction transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\\n    return true;\\n}\\n```\\n```\\nif (\\n    IERC20Upgradeable(lpToken).allowance(\\n        address(this),\\n        address(ichiFarm)\\n    )!= type(uint256).max\\n) {\\n    IERC20Upgradeable(lpToken).safeApprove(\\n        address(ichiFarm),\\n        type(uint256).max\\n    );\\n}\\n```\\n```\\nfunction safeApprove(\\n    IERC20Upgradeable token,\\n    address spender,\\n    uint256 value\\n) internal {\\n    require(\\n        (value == 0) || (token.allowance(address(this), spender) == 0),\\n        \"SafeERC20: approve from non-zero to non-zero allowance\"\\n    );\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n}\\n```",
    "vulnerability": "The WIchiFarm contract is vulnerable to a reentrancy attack due to an incorrect assumption made about the IchiVaultLP's behavior. Specifically, the contract assumes that the `transferFrom` function does not reduce the allowance when the allowance is set to `type(uint256).max`. However, a deployed IchiVault actually reduces the allowance in such cases.\\n\\nWhen the first deposit is made, the allowance is set to `type(uint256).max` using the `safeApprove` function. However, when the second deposit is made, the reduced allowance triggers a new `safeApprove` call, which fails because the current allowance is not zero. This results in a reentrancy attack, effectively breaking the WIchiFarm contract.\\n\\nThe issue arises from the `transferFrom` function in IchiVault, which reduces the allowance regardless of whether the spender is approved for `type(uint256).max` or not. This means that the assumption made by WIchiFarm about the `transferFrom` function's behavior is incorrect, leading to the vulnerability.",
    "type": "allowance underflow"
  },
  "context_similarity_score": 0.8388724327087402,
  "full_llm_prompt": "\n    You are a meticulous smart contract security analyst.\n    Your task is to compare the [Solidity Code (To be analyzed)] against the [Retrieved Context].\n\n    ---\n    [Solidity Code (To be analyzed)]:\n    ```solidity\n    pragma solidity 0.4.26;\n\ninterface IERC20 {\n\n    /**\n\n     * @dev Returns the amount of tokens in existence.\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the amount of tokens owned by `account`.\n\n     */\n\n    function balanceOf(address who) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the remaining number of tokens that `spender` will be\n\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n\n     * zero by default.\n\n     *\n\n     * This value changes when `approve` or `transferFrom` are called.\n\n     */\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a `Transfer` event.\n\n     */\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * > Beware that changing an allowance with this method brings the risk\n\n     * that someone may use both the old and the new allowance by unfortunate\n\n     * transaction ordering. One possible solution to mitigate this race\n\n     * condition is to first reduce the spender's allowance to 0 and set the\n\n     * desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     *\n\n     * Emits an `Approval` event.\n\n     */\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\n     * allowance mechanism. `amount` is then deducted from the caller's\n\n     * allowance.\n\n     *\n\n     * Returns a boolean value indicating whether the operation succeeded.\n\n     *\n\n     * Emits a `Transfer` event.\n\n     */\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n\n\n    /**\n\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * Note that `value` may be zero.\n\n     */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    /**\n\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\n     * a call to `approve`. `value` is the new allowance.\n\n     */\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\ncontract Ownable {\n\n    address private _owner;\n\n\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n    /**\n\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n    * account.\n\n    */\n\n    constructor() public {\n\n        _owner = msg.sender;\n\n    }\n\n\n\n    /**\n\n    * @return the address of the owner.\n\n    */\n\n    function owner() public view returns(address) {\n\n        return _owner;\n\n    }\n\n\n\n    /**\n\n    * @dev Throws if called by any account other than the owner.\n\n    */\n\n    modifier onlyOwner() {\n\n        require(_isOwner());\n\n        _;\n\n    }\n\n\n\n    /**\n\n    * @return true if `msg.sender` is the owner of the contract.\n\n    */\n\n    function _isOwner() internal view returns(bool) {\n\n        return msg.sender == _owner;\n\n    }\n\n\n\n    /**\n\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n    * @param newOwner The address to transfer ownership to.\n\n    */\n\n    function transferOwnership(address newOwner) public onlyOwner {\n\n        _transferOwnership(newOwner);\n\n    }\n\n\n\n    /**\n\n    * @dev Transfers control of the contract to a newOwner.\n\n    * @param newOwner The address to transfer ownership to.\n\n    */\n\n    function _transferOwnership(address newOwner) internal {\n\n        require(newOwner != address(0));\n\n        emit OwnershipTransferred(_owner, newOwner);\n\n        _owner = newOwner;\n\n    }\n\n}\n\nlibrary SafeMath {\n\n\n\n    /**\n\n    * @dev Multiplies two numbers, reverts on overflow.\n\n    */\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\n        // benefit is lost if 'b' is also tested.\n\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint256 c = a * b;\n\n        require(c / a == b);\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n\n    */\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n\n    */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b <= a);\n\n        uint256 c = a - b;\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Adds two numbers, reverts on overflow.\n\n    */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        uint256 c = a + b;\n\n        require(c >= a);\n\n\n\n        return c;\n\n    }\n\n\n\n    /**\n\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n\n    * reverts when dividing by zero.\n\n    */\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b != 0);\n\n        return a % b;\n\n    }\n\n}\n\ncontract Stoppable is Ownable{\n\n    bool public stopped = false;\n\n    \n\n    modifier enabled {\n\n        require (!stopped);\n\n        _;\n\n    }\n\n    \n\n    function stop() external onlyOwner { \n\n        stopped = true; \n\n    }\n\n    \n\n    function start() external onlyOwner {\n\n        stopped = false;\n\n    }    \n\n}\n\ncontract ERC20 is IERC20 {\n\n    using SafeMath for uint256;\n\n\n\n    mapping (address => uint256) private _balances;\n\n\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n\n\n    uint256 private _totalSupply;\n\n\n\n    /**\n\n    * @dev Total number of tokens in existence\n\n    */\n\n    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n\n    }\n\n\n\n    /**\n\n    * @dev Gets the balance of the specified address.\n\n    * @param owner The address to query the balance of.\n\n    * @return An uint256 representing the amount owned by the passed address.\n\n    */\n\n    function balanceOf(address owner) public view returns (uint256) {\n\n        return _balances[owner];\n\n    }\n\n\n\n    /**\n\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n    * @param owner address The address which owns the funds.\n\n    * @param spender address The address which will spend the funds.\n\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n\n    */\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n\n        return _allowed[owner][spender];\n\n    }\n\n\n\n    /**\n\n    * @dev Transfer token for a specified address\n\n    * @param to The address to transfer to.\n\n    * @param value The amount to be transferred.\n\n    */\n\n    function transfer(address to, uint256 value) public returns (bool) {\n\n        require(value <= _balances[msg.sender], \"ERC20: Overdrawn balance\");\n\n        require(to != address(0));\n\n\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n\n        _balances[to] = _balances[to].add(value);\n\n        emit Transfer(msg.sender, to, value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n    * @param spender The address which will spend the funds.\n\n    * @param value The amount of tokens to be spent.\n\n    */\n\n    function approve(address spender, uint256 value) public returns (bool) {\n\n        require(spender != address(0));\n\n\n\n        _allowed[msg.sender][spender] = value;\n\n        emit Approval(msg.sender, spender, value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Transfer tokens from one address to another\n\n    * @param from address The address which you want to send tokens from\n\n    * @param to address The address which you want to transfer to\n\n    * @param value uint256 the amount of tokens to be transferred\n\n    */\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n\n        require(value <= _balances[from], \"ERC20: Overdrawn balance\");\n\n        require(value <= _allowed[from][msg.sender]);\n\n        require(to != address(0));\n\n\n\n        _balances[from] = _balances[from].sub(value);\n\n        _balances[to] = _balances[to].add(value);\n\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n        emit Transfer(from, to, value);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n\n    * approve should be called when allowed_[_spender] == 0. To increment\n\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n\n    * the first transaction is mined)\n\n    * From MonolithDAO Token.sol\n\n    * @param spender The address which will spend the funds.\n\n    * @param addedValue The amount of tokens to increase the allowance by.\n\n    */\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n\n        require(spender != address(0));\n\n\n\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\n    * approve should be called when allowed_[_spender] == 0. To decrement\n\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n\n    * the first transaction is mined)\n\n    * From MonolithDAO Token.sol\n\n    * @param spender The address which will spend the funds.\n\n    * @param subtractedValue The amount of tokens to decrease the allowance by.\n\n    */\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n\n        require(spender != address(0));\n\n\n\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n\n        return true;\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function that mints an amount of the token and assigns it to\n\n    * an account. This encapsulates the modification of balances such that the\n\n    * proper events are emitted.\n\n    * @param account The account that will receive the created tokens.\n\n    * @param amount The amount that will be created.\n\n    */\n\n    function _mint(address account, uint256 amount) internal {\n\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n        emit Transfer(address(0), account, amount);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function that burns an amount of the token of a given\n\n    * account.\n\n    * @param account The account whose tokens will be burnt.\n\n    * @param amount The amount that will be burnt.\n\n    */\n\n    function _burn(address account, uint256 amount) internal {\n\n        require(account != address(0));\n\n        require(amount <= _balances[account], \"ERC20: Overdrawn balance\");\n\n\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        _balances[account] = _balances[account].sub(amount);\n\n        emit Transfer(account, address(0), amount);\n\n    }\n\n\n\n    /**\n\n    * @dev Internal function that burns an amount of the token of a given\n\n    * account, deducting from the sender's allowance for said account. Uses the\n\n    * internal burn function.\n\n    * @param account The account whose tokens will be burnt.\n\n    * @param amount The amount that will be burnt.\n\n    */\n\n    function _burnFrom(address account, uint256 amount) internal {\n\n        require(amount <= _allowed[account][msg.sender], \"ERC20: Overdrawn balance\");\n\n\n\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n\n        // this function needs to emit an event with the updated approval.\n\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);\n\n        _burn(account, amount);\n\n    }\n\n}\n\ncontract ERC20Burnable is ERC20 {\n\n\n\n    /**\n\n    * @dev Burns a specific amount of tokens.\n\n    * @param value The amount of token to be burned.\n\n    */\n\n    function burn(uint256 value) public {\n\n        _burn(msg.sender, value);\n\n    }\n\n\n\n    /**\n\n    * @dev Burns a specific amount of tokens from the target address and decrements allowance\n\n    * @param from address The address which you want to send tokens from\n\n    * @param value uint256 The amount of token to be burned\n\n    */\n\n    function burnFrom(address from, uint256 value) public {\n\n        _burnFrom(from, value);\n\n    }\n\n\n\n    /**\n\n    * @dev Overrides ERC20._burn in order for burn and burnFrom to emit\n\n    * an additional Burn event.\n\n    */\n\n    function _burn(address who, uint256 value) internal {\n\n        super._burn(who, value);\n\n    }\n\n}\n\ncontract ERC20Detailed is IERC20 {\n\n    string private _name;\n\n    string private _symbol;\n\n    uint8 private _decimals;\n\n\n\n    constructor(string memory name, string memory symbol, uint8 decimals) public {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = decimals;\n\n    }\n\n\n\n    /**\n\n    * @return the name of the token.\n\n    */\n\n    function name() public view returns(string memory) {\n\n        return _name;\n\n    }\n\n\n\n    /**\n\n    * @return the symbol of the token.\n\n    */\n\n    function symbol() public view returns(string memory) {\n\n        return _symbol;\n\n    }\n\n\n\n    /**\n\n    * @return the number of decimals of the token.\n\n    */\n\n    function decimals() public view returns(uint8) {\n\n        return _decimals;\n\n    }\n\n}\n\ncontract AXTToken is ERC20Detailed, /*ERC20,*/ ERC20Burnable, Stoppable {\n\n\n\n    constructor (\n\n            string memory name,\n\n            string memory symbol,\n\n            uint256 totalSupply,\n\n            uint8 decimals\n\n    ) ERC20Detailed(name, symbol, decimals)\n\n    public {\n\n        _mint(owner(), totalSupply * 10**uint(decimals));\n\n    }\n\n\n\n    // Don't accept ETH\n\n    function () payable external {\n\n        revert();\n\n    }\n\n\n\n    function mint(address account, uint256 amount) public onlyOwner returns (bool) {\n\n        _mint(account, amount);\n\n        return true;\n\n    }\n\n\n\n    //------------------------\n\n    // Lock account transfer \n\n\n\n    mapping (address => uint256) private _lockTimes;\n\n    mapping (address => uint256) private _lockAmounts;\n\n\n\n    event LockChanged(address indexed account, uint256 releaseTime, uint256 amount);\n\n\n\n    function setLock(address account, uint256 releaseTime, uint256 amount) onlyOwner public {\n\n        _lockTimes[account] = releaseTime; \n\n        _lockAmounts[account] = amount;\n\n        emit LockChanged( account, releaseTime, amount ); \n\n    }\n\n\n\n    function getLock(address account) public view returns (uint256 lockTime, uint256 lockAmount) {\n\n        return (_lockTimes[account], _lockAmounts[account]);\n\n    }\n\n\n\n    function _isLocked(address account, uint256 amount) internal view returns (bool) {\n\n        return _lockTimes[account] != 0 && \n\n            _lockAmounts[account] != 0 && \n\n            _lockTimes[account] > block.timestamp &&\n\n            (\n\n                balanceOf(account) <= _lockAmounts[account] ||\n\n                balanceOf(account).sub(_lockAmounts[account]) < amount\n\n            );\n\n    }\n\n\n\n    function transfer(address recipient, uint256 amount) enabled public returns (bool) {\n\n        require( !_isLocked( msg.sender, amount ) , \"ERC20: Locked balance\");\n\n        return super.transfer(recipient, amount);\n\n    }\n\n\n\n    function transferFrom(address sender, address recipient, uint256 amount) enabled public returns (bool) {\n\n        require( !_isLocked( sender, amount ) , \"ERC20: Locked balance\");\n\n        return super.transferFrom(sender, recipient, amount);\n\n    }\n\n\n\n\n\n}\n\n    ```\n    ---\n    [Retrieved Context]:\n    (This context describes a vulnerability found in a *similar* piece of code)\n    --- BEGIN CONTEXT FROM KNOWLEDGE GRAPH (Similarity Score: 0.8389) ---\n**Retrieved Type:** allowance underflow\n\n**Retrieved Vulnerability:**\nThe WIchiFarm contract is vulnerable to a reentrancy attack due to an incorrect assumption made about the IchiVaultLP's behavior. Specifically, the contract assumes that the `transferFrom` function does not reduce the allowance when the allowance is set to `type(uint256).max`. However, a deployed IchiVault actually reduces the allowance in such cases.\n\nWhen the first deposit is made, the allowance is set to `type(uint256).max` using the `safeApprove` function. However, when the second deposit is made, the reduced allowance triggers a new `safeApprove` call, which fails because the current allowance is not zero. This results in a reentrancy attack, effectively breaking the WIchiFarm contract.\n\nThe issue arises from the `transferFrom` function in IchiVault, which reduces the allowance regardless of whether the spender is approved for `type(uint256).max` or not. This means that the assumption made by WIchiFarm about the `transferFrom` function's behavior is incorrect, leading to the vulnerability.\n\n--- END CONTEXT FROM KNOWLEDGE GRAPH ---\n    ---\n\n    YOUR INSTRUCTIONS:\n    1.  First, analyze the [Retrieved Context]. What specific vulnerability does it describe?\n    2.  Second, carefully examine the [Solidity Code (To be analyzed)].\n    3.  Finally, answer this critical question: Does the [Solidity Code (To be analyzed)] **ALSO** contain the *exact same vulnerability* described in the [Retrieved Context]?\n\n    Please output your findings in this exact format:\n\n    **Vulnerability Name:** <Name of vulnerability or Non-vulnerable if not find>\n    **Reasoning:** <Explain *why* the code is (or is not) vulnerable, comparing it *directly* to the context.>\n    **Recommendation:** <Your suggestion based on the analysis.>\n    \n    ### Response:\n    **Vulnerability Name:**",
  "raw_llm_output": "**Vulnerability Status:** None\n    **Reasoning:** The provided code snippet appears to be unrelated to the vulnerability described in the retrieved context. The retrieved context discusses a vulnerability related to the `transferFrom` function reducing the allowance when the allowance is set to `type(uint256).max`, resulting in a reentrancy attack. However, the provided code snippet contains functions like `transfer` and `transferFrom` that do not seem to exhibit similar behavior. The code snippet also includes various modifiers and functions related to stopping and starting the contract, as well as functions for burning tokens and handling locks. These features appear to be unrelated to the vulnerability described in the retrieved context. Therefore, there is no indication that the provided code snippet exhibits the same vulnerability as the one described in the retrieved context.\n    **Recommendation:** None\n"
}