{
  "address": "2ef506067c75cbb107c0c3e54cdc2fcc1d0b5525",
  "code": "pragma solidity 0.7.1;\npragma experimental ABIEncoderV2;\n\nstruct PoolInfo {\n\n    address swap;       // stableswap contract address.\n\n    address deposit;    // deposit contract address.\n\n    uint256 totalCoins; // Number of coins used in stableswap contract.\n\n    string name;        // Pool name (\"... Pool\").\n\n}\n\nstruct FullAbsoluteTokenAmount {\n\n    AbsoluteTokenAmountMeta base;\n\n    AbsoluteTokenAmountMeta[] underlying;\n\n}\n\nstruct AbsoluteTokenAmountMeta {\n\n    AbsoluteTokenAmount absoluteTokenAmount;\n\n    ERC20Metadata erc20metadata;\n\n}\n\nstruct ERC20Metadata {\n\n    string name;\n\n    string symbol;\n\n    uint8 decimals;\n\n}\n\nstruct AdapterBalance {\n\n    bytes32 protocolAdapterName;\n\n    AbsoluteTokenAmount[] absoluteTokenAmounts;\n\n}\n\nstruct AbsoluteTokenAmount {\n\n    address token;\n\n    uint256 amount;\n\n}\n\nstruct Component {\n\n    address token;\n\n    uint256 rate;\n\n}\n\nstruct TransactionData {\n\n    Action[] actions;\n\n    TokenAmount[] inputs;\n\n    Fee fee;\n\n    AbsoluteTokenAmount[] requiredOutputs;\n\n    uint256 nonce;\n\n}\n\nstruct Action {\n\n    bytes32 protocolAdapterName;\n\n    ActionType actionType;\n\n    TokenAmount[] tokenAmounts;\n\n    bytes data;\n\n}\n\nstruct TokenAmount {\n\n    address token;\n\n    uint256 amount;\n\n    AmountType amountType;\n\n}\n\nstruct Fee {\n\n    uint256 share;\n\n    address beneficiary;\n\n}\n\nenum ActionType { None, Deposit, Withdraw }\n\nenum AmountType { None, Relative, Absolute }\n\nabstract contract ProtocolAdapter {\n\n\n\n    /**\n\n     * @dev MUST return amount and type of the given token\n\n     * locked on the protocol by the given account.\n\n     */\n\n    function getBalance(\n\n        address token,\n\n        address account\n\n    )\n\n        public\n\n        view\n\n        virtual\n\n        returns (uint256);\n\n}\n\nabstract contract Ownable {\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner_, \"O: only owner\");\n\n        _;\n\n    }\n\n\n\n    modifier onlyPendingOwner {\n\n        require(msg.sender == pendingOwner_, \"O: only pending owner\");\n\n        _;\n\n    }\n\n\n\n    address private owner_;\n\n    address private pendingOwner_;\n\n\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n    /**\n\n     * @notice Initializes owner variable with msg.sender address.\n\n     */\n\n    constructor() {\n\n        owner_ = msg.sender;\n\n        emit OwnershipTransferred(address(0), msg.sender);\n\n    }\n\n\n\n    /**\n\n     * @notice Sets pending owner to the desired address.\n\n     * The function is callable only by the owner.\n\n     */\n\n    function proposeOwnership(address newOwner) external onlyOwner {\n\n        require(newOwner != address(0), \"O: empty newOwner\");\n\n        require(newOwner != owner_, \"O: equal to owner_\");\n\n        require(newOwner != pendingOwner_, \"O: equal to pendingOwner_\");\n\n        pendingOwner_ = newOwner;\n\n    }\n\n\n\n    /**\n\n     * @notice Transfers ownership to the pending owner.\n\n     * The function is callable only by the pending owner.\n\n     */\n\n    function acceptOwnership() external onlyPendingOwner {\n\n        emit OwnershipTransferred(owner_, msg.sender);\n\n        owner_ = msg.sender;\n\n        delete pendingOwner_;\n\n    }\n\n\n\n    /**\n\n     * @return Owner of the contract.\n\n     */\n\n    function owner() external view returns (address) {\n\n        return owner_;\n\n    }\n\n\n\n    /**\n\n     * @return Pending owner of the contract.\n\n     */\n\n    function pendingOwner() external view returns (address) {\n\n        return pendingOwner_;\n\n    }\n\n}\n\nabstract contract InteractiveAdapter is ProtocolAdapter {\n\n\n\n    uint256 internal constant DELIMITER = 1e18;\n\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\n\n    /**\n\n     * @dev The function must deposit assets to the protocol.\n\n     * @return MUST return assets to be sent back to the `msg.sender`.\n\n     */\n\n    function deposit(\n\n        TokenAmount[] calldata tokenAmounts,\n\n        bytes calldata data\n\n    )\n\n        external\n\n        payable\n\n        virtual\n\n        returns (address[] memory);\n\n\n\n    /**\n\n     * @dev The function must withdraw assets from the protocol.\n\n     * @return MUST return assets to be sent back to the `msg.sender`.\n\n     */\n\n    function withdraw(\n\n        TokenAmount[] calldata tokenAmounts,\n\n        bytes calldata data\n\n    )\n\n        external\n\n        payable\n\n        virtual\n\n        returns (address[] memory);\n\n\n\n    function getAbsoluteAmountDeposit(\n\n        TokenAmount calldata tokenAmount\n\n    )\n\n        internal\n\n        view\n\n        virtual\n\n        returns (uint256)\n\n    {\n\n        address token = tokenAmount.token;\n\n        uint256 amount = tokenAmount.amount;\n\n        AmountType amountType = tokenAmount.amountType;\n\n\n\n        require(\n\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\n\n            \"IA: bad amount type\"\n\n        );\n\n        if (amountType == AmountType.Relative) {\n\n            require(amount <= DELIMITER, \"IA: bad amount\");\n\n\n\n            uint256 balance;\n\n            if (token == ETH) {\n\n                balance = address(this).balance;\n\n            } else {\n\n                balance = ERC20(token).balanceOf(address(this));\n\n            }\n\n\n\n            if (amount == DELIMITER) {\n\n                return balance;\n\n            } else {\n\n                return mul(balance, amount) / DELIMITER;\n\n            }\n\n        } else {\n\n            return amount;\n\n        }\n\n    }\n\n\n\n    function getAbsoluteAmountWithdraw(\n\n        TokenAmount calldata tokenAmount\n\n    )\n\n        internal\n\n        view\n\n        virtual\n\n        returns (uint256)\n\n    {\n\n        address token = tokenAmount.token;\n\n        uint256 amount = tokenAmount.amount;\n\n        AmountType amountType = tokenAmount.amountType;\n\n\n\n        require(\n\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\n\n            \"IA: bad amount type\"\n\n        );\n\n        if (amountType == AmountType.Relative) {\n\n            require(amount <= DELIMITER, \"IA: bad amount\");\n\n\n\n            uint256 balance = getBalance(token, address(this));\n\n            if (amount == DELIMITER) {\n\n                return balance;\n\n            } else {\n\n                return mul(balance, amount) / DELIMITER;\n\n            }\n\n        } else {\n\n            return amount;\n\n        }\n\n    }\n\n\n\n    function mul(\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint256 c = a * b;\n\n        require(c / a == b, \"IA: mul overflow\");\n\n\n\n        return c;\n\n    }\n\n}\n\ninterface Deposit {\n\n    function add_liquidity(uint256[2] calldata, uint256) external;\n\n    function add_liquidity(uint256[3] calldata, uint256) external;\n\n    function add_liquidity(uint256[4] calldata, uint256) external;\n\n    function remove_liquidity_one_coin(uint256, int128, uint256) external;\n\n}\n\nabstract contract CurveInteractiveAdapter is InteractiveAdapter {\n\n    address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    address internal constant TUSD = 0x0000000000085d4780B73119b644AE5ecd22b376;\n\n    address internal constant BUSD = 0x4Fabb145d64652a948d72533023f6E7A623C7C53;\n\n    address internal constant SUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\n\n    address internal constant PAX = 0x8E870D67F660D95d5be530380D0eC0bd388289E1;\n\n    address internal constant RENBTC = 0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D;\n\n    address internal constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n    address internal constant SBTC = 0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6;\n\n    address internal constant HBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380;\n\n\n\n    function getTokenIndex(address token) internal pure returns (int128) {\n\n        if (token == DAI || token == RENBTC || token == HBTC) {\n\n            return int128(0);\n\n        } else if (token == USDC || token == WBTC) {\n\n            return int128(1);\n\n        } else if (token == USDT || token == SBTC) {\n\n            return int128(2);\n\n        } else if (token == TUSD || token == BUSD || token == SUSD || token == PAX) {\n\n            return int128(3);\n\n        } else {\n\n            revert(\"CIA: bad token\");\n\n        }\n\n    }\n\n}\n\ninterface Stableswap {\n\n    /* solhint-disable-next-line func-name-mixedcase */\n\n    function underlying_coins(int128) external view returns (address);\n\n    function exchange_underlying(int128, int128, uint256, uint256) external;\n\n    function get_dy_underlying(int128, int128, uint256) external view returns (uint256);\n\n}\n\ninterface ERC20 {\n\n    function approve(address, uint256) external returns (bool);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(address, address, uint256) external returns (bool);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function allowance(address, address) external view returns (uint256);\n\n}\n\nlibrary SafeERC20 {\n\n\n\n    function safeTransfer(\n\n        ERC20 token,\n\n        address to,\n\n        uint256 value,\n\n        string memory location\n\n    )\n\n        internal\n\n    {\n\n        callOptionalReturn(\n\n            token,\n\n            abi.encodeWithSelector(\n\n                token.transfer.selector,\n\n                to,\n\n                value\n\n            ),\n\n            \"transfer\",\n\n            location\n\n        );\n\n    }\n\n\n\n    function safeTransferFrom(\n\n        ERC20 token,\n\n        address from,\n\n        address to,\n\n        uint256 value,\n\n        string memory location\n\n    )\n\n        internal\n\n    {\n\n        callOptionalReturn(\n\n            token,\n\n            abi.encodeWithSelector(\n\n                token.transferFrom.selector,\n\n                from,\n\n                to,\n\n                value\n\n            ),\n\n            \"transferFrom\",\n\n            location\n\n        );\n\n    }\n\n\n\n    function safeApprove(\n\n        ERC20 token,\n\n        address spender,\n\n        uint256 value,\n\n        string memory location\n\n    )\n\n        internal\n\n    {\n\n        require(\n\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n\n            \"SafeERC20: bad approve call\"\n\n        );\n\n        callOptionalReturn(\n\n            token,\n\n            abi.encodeWithSelector(\n\n                token.approve.selector,\n\n                spender,\n\n                value\n\n            ),\n\n            \"approve\",\n\n            location\n\n        );\n\n    }\n\n\n\n    /**\n\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\n\n     * relaxing the requirement on the return value: the return value is optional\n\n     * (but if data is returned, it must not be false).\n\n     * @param token The token targeted by the call.\n\n     * @param data The call data (encoded using abi.encode or one of its variants).\n\n     * @param location Location of the call (for debug).\n\n     */\n\n    function callOptionalReturn(\n\n        ERC20 token,\n\n        bytes memory data,\n\n        string memory functionName,\n\n        string memory location\n\n    )\n\n        private\n\n    {\n\n        // We need to perform a low level call here, to bypass Solidity's return data size checking\n\n        // mechanism, since we're implementing it ourselves.\n\n\n\n        // We implement two-steps call as callee is a contract is a responsibility of a caller.\n\n        //  1. The call itself is made, and success asserted\n\n        //  2. The return value is decoded, which in turn checks the size of the returned data.\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n\n        require(\n\n            success,\n\n            string(\n\n                abi.encodePacked(\n\n                    \"SafeERC20: \",\n\n                    functionName,\n\n                    \" failed in \",\n\n                    location\n\n                )\n\n            )\n\n        );\n\n\n\n        if (returndata.length > 0) { // Return data is optional\n\n            require(\n\n                abi.decode(returndata, (bool)),\n\n                string(\n\n                    abi.encodePacked(\n\n                        \"SafeERC20: \",\n\n                        functionName,\n\n                        \" returned false in \",\n\n                        location\n\n                    )\n\n                )\n\n            );\n\n        }\n\n    }\n\n}\n\ncontract ERC20ProtocolAdapter is ProtocolAdapter {\n\n\n\n    /**\n\n     * @return Amount of tokens held by the given account.\n\n     * @dev Implementation of ProtocolAdapter abstract contract function.\n\n     */\n\n    function getBalance(\n\n        address token,\n\n        address account\n\n    )\n\n        public\n\n        view\n\n        override\n\n        returns (uint256)\n\n    {\n\n        return ERC20(token).balanceOf(account);\n\n    }\n\n}\n\ncontract CurveRegistry is Ownable {\n\n\n\n    mapping (address => PoolInfo) internal poolInfo_;\n\n\n\n    function setPoolsInfo(\n\n        address[] memory tokens,\n\n        PoolInfo[] memory poolsInfo\n\n    )\n\n        external\n\n        onlyOwner\n\n    {\n\n        uint256 length = tokens.length;\n\n        for (uint256 i = 0; i < length; i++) {\n\n            setPoolInfo(tokens[i], poolsInfo[i]);\n\n        }\n\n    }\n\n\n\n    function setPoolInfo(\n\n        address token,\n\n        PoolInfo memory poolInfo\n\n    )\n\n        internal\n\n    {\n\n        poolInfo_[token] = poolInfo;\n\n    }\n\n\n\n    function getPoolInfo(address token) external view returns (PoolInfo memory) {\n\n        return poolInfo_[token];\n\n    }\n\n}\n\ncontract CurveAssetInteractiveAdapter is CurveInteractiveAdapter, ERC20ProtocolAdapter {\n\n    using SafeERC20 for ERC20;\n\n\n\n    address internal constant REGISTRY = 0x3fb5Cd4b0603C3D5828D3b5658B10C9CB81aa922;\n\n\n\n    /**\n\n     * @notice Deposits tokens to the Curve pool (pair).\n\n     * @param tokenAmounts Array with one element - TokenAmount struct with\n\n     * underlying token address, underlying token amount to be deposited, and amount type.\n\n     * @param data ABI-encoded additional parameters:\n\n     *     - crvToken - curve token address.\n\n     * @return tokensToBeWithdrawn Array with tokens sent back.\n\n     * @dev Implementation of InteractiveAdapter function.\n\n     */\n\n    function deposit(\n\n        TokenAmount[] calldata tokenAmounts,\n\n        bytes calldata data\n\n    )\n\n        external\n\n        payable\n\n        override\n\n        returns (address[] memory tokensToBeWithdrawn)\n\n    {\n\n        require(tokenAmounts.length == 1, \"CLIA: should be 1 tokenAmount[1]\");\n\n\n\n        address token = tokenAmounts[0].token;\n\n        uint256 amount = getAbsoluteAmountDeposit(tokenAmounts[0]);\n\n\n\n        address crvToken = abi.decode(data, (address));\n\n        tokensToBeWithdrawn = new address[](1);\n\n        tokensToBeWithdrawn[0] = crvToken;\n\n\n\n        PoolInfo memory poolInfo = CurveRegistry(REGISTRY).getPoolInfo(crvToken);\n\n        uint256 totalCoins = poolInfo.totalCoins;\n\n        address callee = poolInfo.deposit;\n\n\n\n        int128 tokenIndex = getTokenIndex(token);\n\n\n\n        uint256[] memory inputAmounts = new uint256[](totalCoins);\n\n        for (uint256 i = 0; i < totalCoins; i++) {\n\n            inputAmounts[i] = i == uint256(tokenIndex) ? amount : 0;\n\n        }\n\n\n\n        ERC20(token).safeApprove(\n\n            callee,\n\n            amount,\n\n            \"CLIA[1]\"\n\n        );\n\n\n\n        if (totalCoins == 2) {\n\n            try Deposit(callee).add_liquidity(\n\n                [inputAmounts[0], inputAmounts[1]],\n\n                0\n\n            ) { // solhint-disable-line no-empty-blocks\n\n            } catch {\n\n                revert(\"CLIA: deposit fail[1]\");\n\n            }\n\n        } else if (totalCoins == 3) {\n\n            try Deposit(callee).add_liquidity(\n\n                [inputAmounts[0], inputAmounts[1], inputAmounts[2]],\n\n                0\n\n            ) { // solhint-disable-line no-empty-blocks\n\n            } catch {\n\n                revert(\"CLIA: deposit fail[2]\");\n\n            }\n\n        } else if (totalCoins == 4) {\n\n            try Deposit(callee).add_liquidity(\n\n                [inputAmounts[0], inputAmounts[1], inputAmounts[2], inputAmounts[3]],\n\n                0\n\n            ) { // solhint-disable-line no-empty-blocks\n\n            } catch {\n\n                revert(\"CLIA: deposit fail[3]\");\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @notice Withdraws tokens from the Curve pool.\n\n     * @param tokenAmounts Array with one element - TokenAmount struct with\n\n     * Curve token address, Curve token amount to be redeemed, and amount type.\n\n     * @param data ABI-encoded additional parameters:\n\n     *     - toToken - destination token address (one of those used in pool).\n\n     * @return tokensToBeWithdrawn Array with one element - destination token address.\n\n     * @dev Implementation of InteractiveAdapter function.\n\n     */\n\n    function withdraw(\n\n        TokenAmount[] calldata tokenAmounts,\n\n        bytes calldata data\n\n    )\n\n        external\n\n        payable\n\n        override\n\n        returns (address[] memory tokensToBeWithdrawn)\n\n    {\n\n        require(tokenAmounts.length == 1, \"CLIA: should be 1 tokenAmount[2]\");\n\n        \n\n        address token = tokenAmounts[0].token;\n\n        uint256 amount = getAbsoluteAmountWithdraw(tokenAmounts[0]);\n\n        address toToken = abi.decode(data, (address));\n\n\n\n        tokensToBeWithdrawn = new address[](1);\n\n        tokensToBeWithdrawn[0] = toToken;\n\n\n\n        PoolInfo memory poolInfo = CurveRegistry(REGISTRY).getPoolInfo(token);\n\n        address callee = poolInfo.deposit;\n\n\n\n        int128 tokenIndex = getTokenIndex(toToken);\n\n\n\n        ERC20(token).safeApprove(\n\n            callee,\n\n            amount,\n\n            \"CLIA[2]\"\n\n        );\n\n\n\n        try Deposit(callee).remove_liquidity_one_coin(\n\n            amount,\n\n            tokenIndex,\n\n            0\n\n        ) { // solhint-disable-line no-empty-blocks\n\n        } catch {\n\n            revert(\"CLIA: withdraw fail\");\n\n        }\n\n    }\n\n}\n",
  "functional_semantic": "**Abstract purpose:** This code defines structs, interfaces, abstract contracts, libraries, and concrete contracts to interact with Curve pools, allowing for deposits and withdrawals of assets.\n\n**Detail Behaviors:**\n1. Defines structs for managing pool information, token amounts, ERC20 metadata, adapter balances, transaction data, actions, and fees.\n2. Defines enums for action types and amount types.\n3. Defines an abstract `ProtocolAdapter` contract for retrieving token balances within a protocol.\n4. Defines an abstract `Ownable` contract for managing contract ownership.\n5. Defines an abstract `InteractiveAdapter` contract, inheriting from `ProtocolAdapter`, for defining deposit and withdraw functionalities.\n6. Defines an interface for interacting with `Deposit` contracts (e.g., Curve's deposit contracts).\n7. Defines an abstract `CurveInteractiveAdapter` contract, inheriting from `InteractiveAdapter`, with Curve-specific functionality, including token index retrieval.\n8. Defines an interface for interacting with `Stableswap` contracts.\n9. Defines an interface for standard `ERC20` token functions.\n10. Defines a `SafeERC20` library for safe token transfers and approvals.\n11. Defines an `ERC20ProtocolAdapter` contract, inheriting from `ProtocolAdapter`, for retrieving ERC20 token balances.\n12. Defines a `CurveRegistry` contract, inheriting from `Ownable`, for storing and managing Curve pool information.\n13. Defines a `CurveAssetInteractiveAdapter` contract, inheriting from `CurveInteractiveAdapter` and `ERC20ProtocolAdapter`, that implements deposit and withdraw functions for Curve pools using a registry to get the pool's details.\n",
  "vuln": "['locked-ether', 'other']",
  "context_retrieved": {
    "functionality": "code block 1:\\n1.  it takes four parameters: `poolcontext`, `strategycontext`, `stakingcontext`, and two `uint256` values, `strategytokens` and `minprimary`.\\n2.  it calculates `bptclaim` by calling `_convertstrategytokenstobptclaim` function from `strategycontext` with `strategytokens` as the input.\\n3.  if `bptclaim` is 0, it returns 0.\\n4.  if `bptclaim` is not 0, it calls `_unstakeandexitpool` function with four parameters: `stakingcontext`, `poolcontext`, `bptclaim`, and `minprimary`.\\n5.  after `_unstakeandexitpool` function call, it updates `strategycontext.vaultstate.totalbptheld` and `strategycontext.vaultstate.totalstrategytokenglobal` by subtracting `bptclaim` and `strategytokens` respectively.\\n6.  finally, it calls `strategycontext.vaultstate.setstrategyvaultstate()`.\\n\\nhigh-level overview:\\nthis code block is part of a smart contract that manages a staking pool. it appears to be a function that allows users to redeem their staked tokens. the function takes four parameters: `poolcontext`, `strategycontext`, `stakingcontext`, and two `uint256` values, `strategytokens` and `minprimary`. it calculates the amount of bpt (base pool token) that can be claimed based on the input `strategytokens`. if the calculated bpt is not 0, it unstakes the tokens and exits the pool, updating the total bpt held and total strategy tokens globally.",
    "vulnerable_code": "```\\nfunction _redeem(\\n    ThreeTokenPoolContext memory poolContext,\\n    StrategyContext memory strategyContext,\\n    AuraStakingContext memory stakingContext,\\n    uint256 strategyTokens,\\n    uint256 minPrimary\\n) internal returns (uint256 finalPrimaryBalance) {\\n    uint256 bptClaim = strategyContext._convertStrategyTokensToBPTClaim(strategyTokens);\\n\\n    if (bptClaim == 0) {\\n        return 0;\\n    }\\n\\n    finalPrimaryBalance = _unstakeAndExitPool({\\n        stakingContext: stakingContext,\\n        poolContext: poolContext,\\n        bptClaim: bptClaim,\\n        minPrimary: minPrimary\\n    });\\n\\n    strategyContext.vaultState.totalBPTHeld -= bptClaim;\\n    strategyContext.vaultState.totalStrategyTokenGlobal -= uint256(strategyTokens);\\n    strategyContext.vaultState.setStrategyVaultState();\\n}\\n```",
    "vulnerability": "The `_redeem` function in the `Boosted3TokenPoolUtils.sol` contract is responsible for claiming BPT amounts using strategy tokens. This function first calls the `_unstakeAndExitPool` function, which likely performs some unstaking and exit operations, and then updates the `totalBPTHeld` and `totalStrategyTokenGlobal` variables.\\n\\nThe `_unstakeAndExitPool` function is called with various context objects, including `stakingContext`, `poolContext`, `bptClaim`, and `minPrimary`. The function returns a value, which is then assigned to the `finalPrimaryBalance` variable.\\n\\nAfter the `_unstakeAndExitPool` function is executed, the `totalBPTHeld` and `totalStrategyTokenGlobal` variables are updated by subtracting the `bptClaim` and `strategyTokens` values, respectively. The `setStrategyVaultState` function is also called to update the vault state.\\n\\nThe order of operations in this function is critical, as the `_unstakeAndExitPool` function may have side effects that need to be considered when updating the `totalBPTHeld` and `totalStrategyTokenGlobal` variables.",
    "type": "token manipulation"
  },
  "context_similarity_score": 0.7990055084228516,
  "full_llm_prompt": "\n    You are a meticulous smart contract security analyst.\n    Your task is to compare the [Solidity Code (To be analyzed)] against the [Retrieved Context].\n\n    ---\n    [Solidity Code (To be analyzed)]:\n    ```solidity\n    pragma solidity 0.7.1;\npragma experimental ABIEncoderV2;\n\nstruct PoolInfo {\n\n    address swap;       // stableswap contract address.\n\n    address deposit;    // deposit contract address.\n\n    uint256 totalCoins; // Number of coins used in stableswap contract.\n\n    string name;        // Pool name (\"... Pool\").\n\n}\n\nstruct FullAbsoluteTokenAmount {\n\n    AbsoluteTokenAmountMeta base;\n\n    AbsoluteTokenAmountMeta[] underlying;\n\n}\n\nstruct AbsoluteTokenAmountMeta {\n\n    AbsoluteTokenAmount absoluteTokenAmount;\n\n    ERC20Metadata erc20metadata;\n\n}\n\nstruct ERC20Metadata {\n\n    string name;\n\n    string symbol;\n\n    uint8 decimals;\n\n}\n\nstruct AdapterBalance {\n\n    bytes32 protocolAdapterName;\n\n    AbsoluteTokenAmount[] absoluteTokenAmounts;\n\n}\n\nstruct AbsoluteTokenAmount {\n\n    address token;\n\n    uint256 amount;\n\n}\n\nstruct Component {\n\n    address token;\n\n    uint256 rate;\n\n}\n\nstruct TransactionData {\n\n    Action[] actions;\n\n    TokenAmount[] inputs;\n\n    Fee fee;\n\n    AbsoluteTokenAmount[] requiredOutputs;\n\n    uint256 nonce;\n\n}\n\nstruct Action {\n\n    bytes32 protocolAdapterName;\n\n    ActionType actionType;\n\n    TokenAmount[] tokenAmounts;\n\n    bytes data;\n\n}\n\nstruct TokenAmount {\n\n    address token;\n\n    uint256 amount;\n\n    AmountType amountType;\n\n}\n\nstruct Fee {\n\n    uint256 share;\n\n    address beneficiary;\n\n}\n\nenum ActionType { None, Deposit, Withdraw }\n\nenum AmountType { None, Relative, Absolute }\n\nabstract contract ProtocolAdapter {\n\n\n\n    /**\n\n     * @dev MUST return amount and type of the given token\n\n     * locked on the protocol by the given account.\n\n     */\n\n    function getBalance(\n\n        address token,\n\n        address account\n\n    )\n\n        public\n\n        view\n\n        virtual\n\n        returns (uint256);\n\n}\n\nabstract contract Ownable {\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner_, \"O: only owner\");\n\n        _;\n\n    }\n\n\n\n    modifier onlyPendingOwner {\n\n        require(msg.sender == pendingOwner_, \"O: only pending owner\");\n\n        _;\n\n    }\n\n\n\n    address private owner_;\n\n    address private pendingOwner_;\n\n\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n    /**\n\n     * @notice Initializes owner variable with msg.sender address.\n\n     */\n\n    constructor() {\n\n        owner_ = msg.sender;\n\n        emit OwnershipTransferred(address(0), msg.sender);\n\n    }\n\n\n\n    /**\n\n     * @notice Sets pending owner to the desired address.\n\n     * The function is callable only by the owner.\n\n     */\n\n    function proposeOwnership(address newOwner) external onlyOwner {\n\n        require(newOwner != address(0), \"O: empty newOwner\");\n\n        require(newOwner != owner_, \"O: equal to owner_\");\n\n        require(newOwner != pendingOwner_, \"O: equal to pendingOwner_\");\n\n        pendingOwner_ = newOwner;\n\n    }\n\n\n\n    /**\n\n     * @notice Transfers ownership to the pending owner.\n\n     * The function is callable only by the pending owner.\n\n     */\n\n    function acceptOwnership() external onlyPendingOwner {\n\n        emit OwnershipTransferred(owner_, msg.sender);\n\n        owner_ = msg.sender;\n\n        delete pendingOwner_;\n\n    }\n\n\n\n    /**\n\n     * @return Owner of the contract.\n\n     */\n\n    function owner() external view returns (address) {\n\n        return owner_;\n\n    }\n\n\n\n    /**\n\n     * @return Pending owner of the contract.\n\n     */\n\n    function pendingOwner() external view returns (address) {\n\n        return pendingOwner_;\n\n    }\n\n}\n\nabstract contract InteractiveAdapter is ProtocolAdapter {\n\n\n\n    uint256 internal constant DELIMITER = 1e18;\n\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\n\n    /**\n\n     * @dev The function must deposit assets to the protocol.\n\n     * @return MUST return assets to be sent back to the `msg.sender`.\n\n     */\n\n    function deposit(\n\n        TokenAmount[] calldata tokenAmounts,\n\n        bytes calldata data\n\n    )\n\n        external\n\n        payable\n\n        virtual\n\n        returns (address[] memory);\n\n\n\n    /**\n\n     * @dev The function must withdraw assets from the protocol.\n\n     * @return MUST return assets to be sent back to the `msg.sender`.\n\n     */\n\n    function withdraw(\n\n        TokenAmount[] calldata tokenAmounts,\n\n        bytes calldata data\n\n    )\n\n        external\n\n        payable\n\n        virtual\n\n        returns (address[] memory);\n\n\n\n    function getAbsoluteAmountDeposit(\n\n        TokenAmount calldata tokenAmount\n\n    )\n\n        internal\n\n        view\n\n        virtual\n\n        returns (uint256)\n\n    {\n\n        address token = tokenAmount.token;\n\n        uint256 amount = tokenAmount.amount;\n\n        AmountType amountType = tokenAmount.amountType;\n\n\n\n        require(\n\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\n\n            \"IA: bad amount type\"\n\n        );\n\n        if (amountType == AmountType.Relative) {\n\n            require(amount <= DELIMITER, \"IA: bad amount\");\n\n\n\n            uint256 balance;\n\n            if (token == ETH) {\n\n                balance = address(this).balance;\n\n            } else {\n\n                balance = ERC20(token).balanceOf(address(this));\n\n            }\n\n\n\n            if (amount == DELIMITER) {\n\n                return balance;\n\n            } else {\n\n                return mul(balance, amount) / DELIMITER;\n\n            }\n\n        } else {\n\n            return amount;\n\n        }\n\n    }\n\n\n\n    function getAbsoluteAmountWithdraw(\n\n        TokenAmount calldata tokenAmount\n\n    )\n\n        internal\n\n        view\n\n        virtual\n\n        returns (uint256)\n\n    {\n\n        address token = tokenAmount.token;\n\n        uint256 amount = tokenAmount.amount;\n\n        AmountType amountType = tokenAmount.amountType;\n\n\n\n        require(\n\n            amountType == AmountType.Relative || amountType == AmountType.Absolute,\n\n            \"IA: bad amount type\"\n\n        );\n\n        if (amountType == AmountType.Relative) {\n\n            require(amount <= DELIMITER, \"IA: bad amount\");\n\n\n\n            uint256 balance = getBalance(token, address(this));\n\n            if (amount == DELIMITER) {\n\n                return balance;\n\n            } else {\n\n                return mul(balance, amount) / DELIMITER;\n\n            }\n\n        } else {\n\n            return amount;\n\n        }\n\n    }\n\n\n\n    function mul(\n\n        uint256 a,\n\n        uint256 b\n\n    )\n\n        internal\n\n        pure\n\n        returns (uint256)\n\n    {\n\n        if (a == 0) {\n\n            return 0;\n\n        }\n\n\n\n        uint256 c = a * b;\n\n        require(c / a == b, \"IA: mul overflow\");\n\n\n\n        return c;\n\n    }\n\n}\n\ninterface Deposit {\n\n    function add_liquidity(uint256[2] calldata, uint256) external;\n\n    function add_liquidity(uint256[3] calldata, uint256) external;\n\n    function add_liquidity(uint256[4] calldata, uint256) external;\n\n    function remove_liquidity_one_coin(uint256, int128, uint256) external;\n\n}\n\nabstract contract CurveInteractiveAdapter is InteractiveAdapter {\n\n    address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    address internal constant TUSD = 0x0000000000085d4780B73119b644AE5ecd22b376;\n\n    address internal constant BUSD = 0x4Fabb145d64652a948d72533023f6E7A623C7C53;\n\n    address internal constant SUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\n\n    address internal constant PAX = 0x8E870D67F660D95d5be530380D0eC0bd388289E1;\n\n    address internal constant RENBTC = 0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D;\n\n    address internal constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n    address internal constant SBTC = 0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6;\n\n    address internal constant HBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380;\n\n\n\n    function getTokenIndex(address token) internal pure returns (int128) {\n\n        if (token == DAI || token == RENBTC || token == HBTC) {\n\n            return int128(0);\n\n        } else if (token == USDC || token == WBTC) {\n\n            return int128(1);\n\n        } else if (token == USDT || token == SBTC) {\n\n            return int128(2);\n\n        } else if (token == TUSD || token == BUSD || token == SUSD || token == PAX) {\n\n            return int128(3);\n\n        } else {\n\n            revert(\"CIA: bad token\");\n\n        }\n\n    }\n\n}\n\ninterface Stableswap {\n\n    /* solhint-disable-next-line func-name-mixedcase */\n\n    function underlying_coins(int128) external view returns (address);\n\n    function exchange_underlying(int128, int128, uint256, uint256) external;\n\n    function get_dy_underlying(int128, int128, uint256) external view returns (uint256);\n\n}\n\ninterface ERC20 {\n\n    function approve(address, uint256) external returns (bool);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(address, address, uint256) external returns (bool);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function allowance(address, address) external view returns (uint256);\n\n}\n\nlibrary SafeERC20 {\n\n\n\n    function safeTransfer(\n\n        ERC20 token,\n\n        address to,\n\n        uint256 value,\n\n        string memory location\n\n    )\n\n        internal\n\n    {\n\n        callOptionalReturn(\n\n            token,\n\n            abi.encodeWithSelector(\n\n                token.transfer.selector,\n\n                to,\n\n                value\n\n            ),\n\n            \"transfer\",\n\n            location\n\n        );\n\n    }\n\n\n\n    function safeTransferFrom(\n\n        ERC20 token,\n\n        address from,\n\n        address to,\n\n        uint256 value,\n\n        string memory location\n\n    )\n\n        internal\n\n    {\n\n        callOptionalReturn(\n\n            token,\n\n            abi.encodeWithSelector(\n\n                token.transferFrom.selector,\n\n                from,\n\n                to,\n\n                value\n\n            ),\n\n            \"transferFrom\",\n\n            location\n\n        );\n\n    }\n\n\n\n    function safeApprove(\n\n        ERC20 token,\n\n        address spender,\n\n        uint256 value,\n\n        string memory location\n\n    )\n\n        internal\n\n    {\n\n        require(\n\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n\n            \"SafeERC20: bad approve call\"\n\n        );\n\n        callOptionalReturn(\n\n            token,\n\n            abi.encodeWithSelector(\n\n                token.approve.selector,\n\n                spender,\n\n                value\n\n            ),\n\n            \"approve\",\n\n            location\n\n        );\n\n    }\n\n\n\n    /**\n\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\n\n     * relaxing the requirement on the return value: the return value is optional\n\n     * (but if data is returned, it must not be false).\n\n     * @param token The token targeted by the call.\n\n     * @param data The call data (encoded using abi.encode or one of its variants).\n\n     * @param location Location of the call (for debug).\n\n     */\n\n    function callOptionalReturn(\n\n        ERC20 token,\n\n        bytes memory data,\n\n        string memory functionName,\n\n        string memory location\n\n    )\n\n        private\n\n    {\n\n        // We need to perform a low level call here, to bypass Solidity's return data size checking\n\n        // mechanism, since we're implementing it ourselves.\n\n\n\n        // We implement two-steps call as callee is a contract is a responsibility of a caller.\n\n        //  1. The call itself is made, and success asserted\n\n        //  2. The return value is decoded, which in turn checks the size of the returned data.\n\n\n\n        // solhint-disable-next-line avoid-low-level-calls\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n\n        require(\n\n            success,\n\n            string(\n\n                abi.encodePacked(\n\n                    \"SafeERC20: \",\n\n                    functionName,\n\n                    \" failed in \",\n\n                    location\n\n                )\n\n            )\n\n        );\n\n\n\n        if (returndata.length > 0) { // Return data is optional\n\n            require(\n\n                abi.decode(returndata, (bool)),\n\n                string(\n\n                    abi.encodePacked(\n\n                        \"SafeERC20: \",\n\n                        functionName,\n\n                        \" returned false in \",\n\n                        location\n\n                    )\n\n                )\n\n            );\n\n        }\n\n    }\n\n}\n\ncontract ERC20ProtocolAdapter is ProtocolAdapter {\n\n\n\n    /**\n\n     * @return Amount of tokens held by the given account.\n\n     * @dev Implementation of ProtocolAdapter abstract contract function.\n\n     */\n\n    function getBalance(\n\n        address token,\n\n        address account\n\n    )\n\n        public\n\n        view\n\n        override\n\n        returns (uint256)\n\n    {\n\n        return ERC20(token).balanceOf(account);\n\n    }\n\n}\n\ncontract CurveRegistry is Ownable {\n\n\n\n    mapping (address => PoolInfo) internal poolInfo_;\n\n\n\n    function setPoolsInfo(\n\n        address[] memory tokens,\n\n        PoolInfo[] memory poolsInfo\n\n    )\n\n        external\n\n        onlyOwner\n\n    {\n\n        uint256 length = tokens.length;\n\n        for (uint256 i = 0; i < length; i++) {\n\n            setPoolInfo(tokens[i], poolsInfo[i]);\n\n        }\n\n    }\n\n\n\n    function setPoolInfo(\n\n        address token,\n\n        PoolInfo memory poolInfo\n\n    )\n\n        internal\n\n    {\n\n        poolInfo_[token] = poolInfo;\n\n    }\n\n\n\n    function getPoolInfo(address token) external view returns (PoolInfo memory) {\n\n        return poolInfo_[token];\n\n    }\n\n}\n\ncontract CurveAssetInteractiveAdapter is CurveInteractiveAdapter, ERC20ProtocolAdapter {\n\n    using SafeERC20 for ERC20;\n\n\n\n    address internal constant REGISTRY = 0x3fb5Cd4b0603C3D5828D3b5658B10C9CB81aa922;\n\n\n\n    /**\n\n     * @notice Deposits tokens to the Curve pool (pair).\n\n     * @param tokenAmounts Array with one element - TokenAmount struct with\n\n     * underlying token address, underlying token amount to be deposited, and amount type.\n\n     * @param data ABI-encoded additional parameters:\n\n     *     - crvToken - curve token address.\n\n     * @return tokensToBeWithdrawn Array with tokens sent back.\n\n     * @dev Implementation of InteractiveAdapter function.\n\n     */\n\n    function deposit(\n\n        TokenAmount[] calldata tokenAmounts,\n\n        bytes calldata data\n\n    )\n\n        external\n\n        payable\n\n        override\n\n        returns (address[] memory tokensToBeWithdrawn)\n\n    {\n\n        require(tokenAmounts.length == 1, \"CLIA: should be 1 tokenAmount[1]\");\n\n\n\n        address token = tokenAmounts[0].token;\n\n        uint256 amount = getAbsoluteAmountDeposit(tokenAmounts[0]);\n\n\n\n        address crvToken = abi.decode(data, (address));\n\n        tokensToBeWithdrawn = new address[](1);\n\n        tokensToBeWithdrawn[0] = crvToken;\n\n\n\n        PoolInfo memory poolInfo = CurveRegistry(REGISTRY).getPoolInfo(crvToken);\n\n        uint256 totalCoins = poolInfo.totalCoins;\n\n        address callee = poolInfo.deposit;\n\n\n\n        int128 tokenIndex = getTokenIndex(token);\n\n\n\n        uint256[] memory inputAmounts = new uint256[](totalCoins);\n\n        for (uint256 i = 0; i < totalCoins; i++) {\n\n            inputAmounts[i] = i == uint256(tokenIndex) ? amount : 0;\n\n        }\n\n\n\n        ERC20(token).safeApprove(\n\n            callee,\n\n            amount,\n\n            \"CLIA[1]\"\n\n        );\n\n\n\n        if (totalCoins == 2) {\n\n            try Deposit(callee).add_liquidity(\n\n                [inputAmounts[0], inputAmounts[1]],\n\n                0\n\n            ) { // solhint-disable-line no-empty-blocks\n\n            } catch {\n\n                revert(\"CLIA: deposit fail[1]\");\n\n            }\n\n        } else if (totalCoins == 3) {\n\n            try Deposit(callee).add_liquidity(\n\n                [inputAmounts[0], inputAmounts[1], inputAmounts[2]],\n\n                0\n\n            ) { // solhint-disable-line no-empty-blocks\n\n            } catch {\n\n                revert(\"CLIA: deposit fail[2]\");\n\n            }\n\n        } else if (totalCoins == 4) {\n\n            try Deposit(callee).add_liquidity(\n\n                [inputAmounts[0], inputAmounts[1], inputAmounts[2], inputAmounts[3]],\n\n                0\n\n            ) { // solhint-disable-line no-empty-blocks\n\n            } catch {\n\n                revert(\"CLIA: deposit fail[3]\");\n\n            }\n\n        }\n\n    }\n\n\n\n    /**\n\n     * @notice Withdraws tokens from the Curve pool.\n\n     * @param tokenAmounts Array with one element - TokenAmount struct with\n\n     * Curve token address, Curve token amount to be redeemed, and amount type.\n\n     * @param data ABI-encoded additional parameters:\n\n     *     - toToken - destination token address (one of those used in pool).\n\n     * @return tokensToBeWithdrawn Array with one element - destination token address.\n\n     * @dev Implementation of InteractiveAdapter function.\n\n     */\n\n    function withdraw(\n\n        TokenAmount[] calldata tokenAmounts,\n\n        bytes calldata data\n\n    )\n\n        external\n\n        payable\n\n        override\n\n        returns (address[] memory tokensToBeWithdrawn)\n\n    {\n\n        require(tokenAmounts.length == 1, \"CLIA: should be 1 tokenAmount[2]\");\n\n        \n\n        address token = tokenAmounts[0].token;\n\n        uint256 amount = getAbsoluteAmountWithdraw(tokenAmounts[0]);\n\n        address toToken = abi.decode(data, (address));\n\n\n\n        tokensToBeWithdrawn = new address[](1);\n\n        tokensToBeWithdrawn[0] = toToken;\n\n\n\n        PoolInfo memory poolInfo = CurveRegistry(REGISTRY).getPoolInfo(token);\n\n        address callee = poolInfo.deposit;\n\n\n\n        int128 tokenIndex = getTokenIndex(toToken);\n\n\n\n        ERC20(token).safeApprove(\n\n            callee,\n\n            amount,\n\n            \"CLIA[2]\"\n\n        );\n\n\n\n        try Deposit(callee).remove_liquidity_one_coin(\n\n            amount,\n\n            tokenIndex,\n\n            0\n\n        ) { // solhint-disable-line no-empty-blocks\n\n        } catch {\n\n            revert(\"CLIA: withdraw fail\");\n\n        }\n\n    }\n\n}\n\n    ```\n    ---\n    [Retrieved Context]:\n    (This context describes a vulnerability found in a *similar* piece of code)\n    --- BEGIN CONTEXT FROM KNOWLEDGE GRAPH (Similarity Score: 0.7990) ---\n**Retrieved Type:** token manipulation\n\n**Retrieved Vulnerability:**\nThe `_redeem` function in the `Boosted3TokenPoolUtils.sol` contract is responsible for claiming BPT amounts using strategy tokens. This function first calls the `_unstakeAndExitPool` function, which likely performs some unstaking and exit operations, and then updates the `totalBPTHeld` and `totalStrategyTokenGlobal` variables.\n\nThe `_unstakeAndExitPool` function is called with various context objects, including `stakingContext`, `poolContext`, `bptClaim`, and `minPrimary`. The function returns a value, which is then assigned to the `finalPrimaryBalance` variable.\n\nAfter the `_unstakeAndExitPool` function is executed, the `totalBPTHeld` and `totalStrategyTokenGlobal` variables are updated by subtracting the `bptClaim` and `strategyTokens` values, respectively. The `setStrategyVaultState` function is also called to update the vault state.\n\nThe order of operations in this function is critical, as the `_unstakeAndExitPool` function may have side effects that need to be considered when updating the `totalBPTHeld` and `totalStrategyTokenGlobal` variables.\n\n--- END CONTEXT FROM KNOWLEDGE GRAPH ---\n    ---\n\n    YOUR INSTRUCTIONS:\n    1.  First, analyze the [Retrieved Context]. What specific vulnerability does it describe?\n    2.  Second, carefully examine the [Solidity Code (To be analyzed)].\n    3.  Finally, answer this critical question: Does the [Solidity Code (To be analyzed)] **ALSO** contain the *exact same vulnerability* described in the [Retrieved Context]?\n\n    Please output your findings in this exact format:\n\n    **Vulnerability Name:** <Name of vulnerability or Non-vulnerable if not find>\n    **Reasoning:** <Explain *why* the code is (or is not) vulnerable, comparing it *directly* to the context.>\n    **Recommendation:** <Your suggestion based on the analysis.>\n    \n    ### Response:\n    **Vulnerability Name:**",
  "raw_llm_output": "**Vulnerability Status:** None\n    **Reasoning:** The provided code snippet does not exhibit any vulnerabilities related to token manipulation. It appears to be a well-structured and secure implementation of an interactive adapter contract, which interacts with a Curve registry and pool contracts. The code includes functions for depositing and withdrawing tokens, along with necessary approvals and error handling mechanisms. There are no obvious issues or potential attack vectors identified in the code, suggesting that it is free from vulnerabilities.\n    **Recommendation:** None\n"
}