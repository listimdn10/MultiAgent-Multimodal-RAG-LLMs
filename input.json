{
  "code": "pragma solidity ^0.8.0;\n\ncontract owned {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner public {\n        owner = newOwner;\n    }\n}\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) external; }\n\ncontract TokenERC20 {\n    \n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    \n    uint256 public totalSupply;\n\n    \n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Burn(address indexed from, uint256 value);\n\n\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) {\n        totalSupply = initialSupply * 10 ** uint256(decimals); \n        balanceOf[msg.sender] = totalSupply;             \n        name = tokenName;                    \n        symbol = tokenSymbol;              \n    }\n\n\n    function _transfer(address _from, address _to, uint _value) internal virtual {\n        \n        require(_to != address(0));\n        \n        require(balanceOf[_from] >= _value);\n        \n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        \n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        \n        balanceOf[_from] -= _value;\n        \n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        \n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     \n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);  \n        balanceOf[msg.sender] -= _value;      \n        totalSupply -= _value;               \n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);               \n        require(_value <= allowance[_from][msg.sender]);  \n        balanceOf[_from] -= _value;                      \n        allowance[_from][msg.sender] -= _value;    \n        totalSupply -= _value;                  \n        emit Burn(_from, _value);\n        return true;\n    }\n}\n\ncontract SETC is owned, TokenERC20 {\n    mapping (address => bool) public frozenAccount;\n    event FrozenFunds(address target, bool frozen);\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) TokenERC20(initialSupply, tokenName, tokenSymbol) {}\n\n    function _transfer(address _from, address _to, uint _value) internal override {\n        require (_to != address(0));                               \n        require (balanceOf[_from] >= _value);               \n        require (balanceOf[_to] + _value >= balanceOf[_to]); \n        require(!frozenAccount[_from]);                     \n        require(!frozenAccount[_to]);                       \n        balanceOf[_from] -= _value;                         \n        balanceOf[_to] += _value;                           \n        emit Transfer(_from, _to, _value);\n    }\n\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        emit Transfer(address(0), address(this), mintedAmount);\n        emit Transfer(address(this), target, mintedAmount);\n    }\n\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\n}",
  "functional_semantic": "Abstract purpose: The code implements a standard ERC20 token with ownership control, minting capabilities, and account freezing functionality.\n\nDetail Behaviors:\n1. Defines an `owned` contract to manage ownership of the contract.\n2. Defines a `TokenERC20` contract implementing the core ERC20 token functionality like transfer, allowance, and burning.\n3. Defines a `SETC` contract, inheriting from `owned` and `TokenERC20`, adding specific functionalities like freezing accounts and minting new tokens, restricted to the owner.\n4. Allows the contract owner to transfer ownership to another address.\n5. Enables users to transfer tokens to other addresses.\n6. Enables users to approve other addresses to spend their tokens.\n7. Enables users to burn their own tokens or tokens they're approved to burn.\n8. Includes events for transfers and burns for logging purposes.\n9. Initializes the token with a specified supply, name, and symbol during construction.\n10. Allows the owner to mint new tokens.\n11. Allows the owner to freeze and unfreeze accounts, preventing them from transferring tokens.\n"
}