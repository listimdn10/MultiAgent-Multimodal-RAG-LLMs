{
  "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_Reentrancy {\n    mapping(address => uint) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint amount = balances[msg.sender];\n        require(amount > 0, \"Insufficient balance\");\n\n        // Vulnerability: Ether is sent before updating the user's balance, allowing reentrancy.\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        // Update balance after sending Ether\n        balances[msg.sender] = 0;\n    }\n}",
  "functional_semantic": "Abstract purpose: This Solidity smart contract serves as a demonstration of a highly common Reentrancy vulnerability by executing an external Ether transfer before updating the user's recorded balance.\n\nDetail Behaviors:\n1. Manages public balances using an address-to-uint mapping.\n2. Accepts payable deposits from external users.\n3. Increments the sender's recorded balance upon deposit.\n4. Allows external users to withdraw their full recorded balance.\n5. Executes the Ether transfer during withdrawal using a low-level `call` function.\n6. Resets the user's internal balance to zero only after the external transfer attempt."
}